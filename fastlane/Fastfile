require 'active_support'
require 'active_support/core_ext'

require_relative 'badge'

# taken from previous GitHub repository
BUILD_OFFSET = 861
DEFAULT_APP_NAME = "NL Wallet"
BADGE_FONT='../wallet_app/assets/non-free/fonts/rijksoverheid-sans-web-text-regular.ttf'

# opt out of analytics
opt_out_usage

# do not generate README.md
skip_docs

private_lane :get_app_identifier do
  app_identifier = CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)
  UI.user_error!("No app_identifier set") if app_identifier.blank?

  app_identifier
end

private_lane :get_local_version_and_build do
  yaml_data = YAML.load_file("../wallet_app/pubspec.yaml")
  version_parts = yaml_data["version"].split("-", 2)

  # If building locally, and 2nd part of version is nil or "dev", rewrite to 0.
  if version_parts[1].nil? || version_parts[1] == "dev"
    UI.message("App version_part[1] is \"#{version_parts[1]}\", rewriting to \"0\"")
    version_parts[1] = "0"
  end
  version_parts
end

private_lane :flutter_cmd do
  sh "which", "fvm" do |status|
    if status.success?
      ["fvm", "flutter"]
    else
      sh "which", "flutter", error_callback: Proc.new {
        UI.user_error!('Neither "fvm" nor "flutter" command found')
      }
      ["flutter"]
    end
  end
end

private_lane :get_newest_file do |options|
  Dir.chdir("..") do
    Dir.glob("*.#{options[:extension]}").max_by {|f| File.mtime(f)}
  end
end

# Upload debug symbols to Sentry.
# Requires the following environment variables: [SENTRY_AUTH_TOKEN, SENTRY_ORG, SENTRY_PROJECT, SENTRY_URL].
# SENTRY_AUTH_TOKEN enables the sentry_dart_plugin, after which the existense of the other variables is checked.
private_lane :upload_sentry_symbols do
  unless ENV["SENTRY_AUTH_TOKEN"].blank? then
    UI.user_error!("Missing environment variable 'SENTRY_ORG'") if ENV["SENTRY_ORG"].blank?
    UI.user_error!("Missing environment variable 'SENTRY_PROJECT'") if ENV["SENTRY_PROJECT"].blank?
    UI.user_error!("Missing environment variable 'SENTRY_URL'") if ENV["SENTRY_URL"].blank?
    sh(*flutter_cmd, "packages", "pub", "run", "sentry_dart_plugin")
  end
end

lane :upload_to_play_store_internal_track do |options|
  package_name = options[:package_name]
  version = options[:version]
  json_key_data = options[:json_key_data]

  upload_to_play_store(
    package_name: package_name,
    track: "internal",
    json_key_data: json_key_data,
    aab: "#{package_name}-#{version}-release.aab",
    skip_upload_apk: true
  )
end

private_lane :upload_to_browserstack do |options|
  Dir.chdir("..") do
    sh(
      "curl",
      "-u", "#{options[:user]}:#{options[:key]}",
      "-X", "POST",
      "https://api-cloud.browserstack.com/app-automate/upload",
      "-F", "file=@#{options[:file]}",
      "-F", "custom_id=#{options[:custom_id]}",
      log: false
    )
  end
end

platform :android do
  desc "Add badge to launcher icons"
  lane :add_badge do |options|
    badge = Badge::new((options[:label] || 'latest').upcase, BADGE_FONT)
    Pathname.new('../wallet_app').glob('**/ic_launcher*.{png,webp}').each do |i|
      compose = i.basename.to_s.match?('foreground') ? 'over' : 'atop'
      badge.add_to_image(i, font_rel_size: 0.13, translate: 0.66, compose: compose)
      badge.add_seasonal_image(i, compose: compose)
    end
  end

  desc "Build and sign Android app"
  lane :build do |options|

    if options[:build_mode].nil? || options[:build_mode] == "release"
      ensure_env_vars(
        env_vars: ['CONFIG_ENV']
      )
    end

    application_id = options[:application_id] || get_app_identifier
    app_name = options[:app_name] || DEFAULT_APP_NAME

    universal_link_base = options[:universal_link_base]
    sentry_dsn = ENV["SENTRY_DSN"]
    sentry_environment = ENV["SENTRY_ENVIRONMENT"]
    sentry_release = ENV["SENTRY_RELEASE"]

    local_version, local_build = get_local_version_and_build
    build = options[:build] || local_build
    version = options[:version].blank? ? local_version : options[:version]
    file_format = options[:file_format] || "aab"
    build_mode = options[:build_mode] || "release"
    mock_repositories = options[:mock] || false
    demo_index_url = options[:demo_index_url] || ""

    UI.user_error!("Invalid file_format: #{file_format}") unless ["aab", "apk"].include? file_format
    UI.user_error!("Invalid build_mode: #{build_mode}") unless ["release", "profile", "debug"].include? build_mode

    file_format_command = file_format == "aab" ? "appbundle" : file_format
    file_format_path = file_format == "aab" ? "bundle" : file_format

    flutter = flutter_cmd

    Dir.chdir("../wallet_app") do
      sh(*flutter, "pub", "get", "--enforce-lockfile")
      sh({ "APPLICATION_ID" => application_id, "APP_NAME" => app_name },
        *flutter, "build", file_format_command,
            "--build-number", build.to_s,
            "--build-name", version.to_s,
            "--#{build_mode}",
            "--dart-define=MOCK_REPOSITORIES=#{mock_repositories}",
            "--dart-define=DEMO_INDEX_URL=#{demo_index_url}",
            "--dart-define=UL_HOSTNAME=#{universal_link_base}",
            "--dart-define=SENTRY_DSN=#{sentry_dsn}",
            "--dart-define=SENTRY_ENVIRONMENT=#{sentry_environment}",
            "--dart-define=SENTRY_RELEASE=#{sentry_release}",
      )

      upload_sentry_symbols

      source_filepath = "build/app/outputs/#{file_format_path}/#{build_mode}/app-#{build_mode}.#{file_format}"
      target_filepath = "../#{application_id}-#{version}-#{build_mode}.#{file_format}"

      FileUtils.mv(source_filepath, target_filepath)
    end
  end

  desc "Deploy Android app from GitLab CI"
  lane :ci_deploy do |options|
    json_key_data = ENV["JSON_KEY_DATA"]
    UI.user_error!("No JSON_KEY_DATA environment variable given") if json_key_data.blank?

    application_id = options[:application_id]
    UI.user_error!("No application id set") if application_id.blank?

    # Retrieve local version
    local_version, _ = get_local_version_and_build
    version = options[:version].blank? ? local_version : options[:version]

    # upload non-mock app
    upload_to_play_store_internal_track(package_name: application_id, version: version, json_key_data: json_key_data)
  end

  desc "Upload Android app to BrowserStack from GitLab CI"
  lane :ci_browserstack do |options|
    browserstack_user = ENV["BROWSERSTACK_USER"]
    browserstack_key = ENV["BROWSERSTACK_KEY"]
    commit_sha = ENV["CI_COMMIT_SHA"]

    UI.user_error!("No BROWSERSTACK_USER environment variable set") if browserstack_user.blank?
    UI.user_error!("No BROWSERSTACK_KEY environment variable set") if browserstack_key.blank?

    application_id = options[:application_id]
    UI.user_error!("No application id set") if application_id.blank?

    local_version, _ = get_local_version_and_build
    version = options[:version].blank? ? local_version : options[:version]

    browserstack(
      file: "#{application_id}-#{version || local_version}-release.apk",
      user: browserstack_user,
      key: browserstack_key,
      application_id: application_id,
      commit_sha: commit_sha,
    )
  end

  desc "Upload Android app to BrowserStack"
  lane :browserstack do |options|
    file = options[:file]
    user = options[:user]
    key = options[:key]
    application_id = options[:application_id]
    commit_sha = options[:commit_sha]

    upload_to_browserstack(file: file, user: user, key: key, custom_id: "NLWalletAndroid_#{application_id}_#{commit_sha}")
  end
end

platform :ios do
  desc "Add badge to app icons"
  lane :add_badge do |options|
    badge = Badge::new((options[:label] || 'latest').upcase, BADGE_FONT)
    Pathname.new('../wallet_app').glob('**/AppIcon.appiconset/*.png').each do |i|
      badge.add_to_image(i, font_rel_size: 0.15, translate: 0.70)
      badge.add_seasonal_image(i)
    end
  end

  desc "Deploy iOS app from GitLab CI"
  lane :ci_deploy do |options|
    # Get app identifier
    bundle_id = options[:bundle_id]
    UI.user_error!("No bundle id given") if bundle_id.blank?

    # Parse API key values and convert to a Fastlane API key object
    asc_secrets_base64_json = ENV["APP_STORE_CONNECT_SECRETS_BASE64_JSON"]
    UI.user_error!("No APP_STORE_CONNECT_SECRETS_BASE64_JSON environment variable given") if asc_secrets_base64_json.blank?

    asc_secrets = begin
      JSON.parse(asc_secrets_base64_json).map{ |k, v| [k, Base64.strict_decode64(v)] }.to_h
    rescue JSON::ParserError
      UI.user_error!("Unable to JSON parse APP_STORE_CONNECT_SECRETS_BASE64_JSON")
    rescue ArgumentError
      UI.user_error!("Unable to base64 decode values in APP_STORE_CONNECT_SECRETS_BASE64_JSON")
    end

    api_key = app_store_connect_api_key(
      key_id: asc_secrets["key_id"],
      issuer_id: asc_secrets["issuer_id"],
      key_content: asc_secrets["private_key"],
    )

    upload_to_testflight(
      skip_submission: true,
      skip_waiting_for_build_processing: true,
      app_identifier: bundle_id,
      api_key: api_key,
    )
  end

  desc "Test iOS app"
  lane :test do
    run_tests(
      project: "wallet_core/wallet/platform_support/ios/PlatformSupport.xcodeproj",
      scheme: "PlatformSupport",
      xcodebuild_formatter: 'xcpretty',
    )

    # This adjust the working directory so that the "wallet_core/wallet/platform_support/ios/"
    # path prefix is not present in the coverage output file. Note that we need to be one
    # directory higher, because of how Fastlane determines the current working directory.
    Dir.chdir("../wallet_core/wallet/platform_support/ios/PlatformSupport") do
      slather(
        output_directory: "../../../../fastlane/test_output",
        proj: "PlatformSupport.xcodeproj",
        scheme: "PlatformSupport",
        binary_basename: "libPlatformSupport",
        ignore: "../**", # ignore files outside of the project dir
        arch: "arm64", # pick an architecture because of universal binary
        sonarqube_xml: true,
      )

      slather(
        output_directory: "../../../../fastlane/test_output",
        proj: "PlatformSupport.xcodeproj",
        scheme: "PlatformSupport",
        binary_basename: "libPlatformSupport",
        ignore: "../**", # ignore files outside of the project dir
        arch: "arm64", # pick an architecture because of universal binary
        cobertura_xml: true,
      )
    end
  end

  desc "Build iOS app"
  lane :build do |options|

    if options[:build_mode].nil? || options[:build_mode] == "release"
      ensure_env_vars(
        env_vars: ['CONFIG_ENV']
      )
    end

    app_name = options[:app_name] || DEFAULT_APP_NAME
    universal_link_base = options[:universal_link_base]
    sentry_dsn = ENV["SENTRY_DSN"]
    sentry_environment = ENV["SENTRY_ENVIRONMENT"]
    sentry_release = ENV["SENTRY_RELEASE"]

    local_version, local_build = get_local_version_and_build
    build = options[:build] || local_build
    version = options[:version].blank? ? local_version : options[:version]
    build_mode = options[:build_mode] || "release"
    fake_attestation = !!options[:fake_attestation]
    mock_repositories = options[:mock] || false
    demo_index_url = options[:demo_index_url] || ""

    UI.user_error!("Invalid build_mode: #{build_mode}") unless ["release", "profile", "debug"].include? build_mode

    flutter = flutter_cmd

    UI.message("Going to build iOS name #{app_name}, build name #{version} with number #{build} in mode #{build_mode}")
    UI.message("Using UL hostname \"#{universal_link_base}\", #{fake_attestation ? "fake" : "real"} key/app attestation and #{mock_repositories ? "mock repositories" : "Rust core"}")

    # Set the app name and have Flutter build it
    Dir.chdir("../wallet_app") do
      sh(*flutter, "pub", "get", "--enforce-lockfile")

      # Although installing pods is part of the "flutter build" command below,
      # preload them now in order to ensure the "--deployment" flag is used
      # and an error occurs if "Podfile.lock" needs to be modified.
      Dir.chdir("ios") do
        sh("bundle", "exec", "pod", "install", "--allow-root", "--deployment")
      end

      sh({ "APP_NAME" => app_name },
        *flutter, "build", "ipa",
            "--build-number", build.to_s,
            "--build-name", version.to_s,
            "--no-codesign",
            "--#{build_mode}",
            "--dart-define=FAKE_ATTESTATION=#{fake_attestation}",
            "--dart-define=MOCK_REPOSITORIES=#{mock_repositories}",
            "--dart-define=DEMO_INDEX_URL=#{demo_index_url}",
            "--dart-define=UL_HOSTNAME=#{universal_link_base}",
            "--dart-define=SENTRY_DSN=#{sentry_dsn}",
            "--dart-define=SENTRY_ENVIRONMENT=#{sentry_environment}",
            "--dart-define=SENTRY_RELEASE=#{sentry_release}",
      )

      upload_sentry_symbols
      extract_entitlements
    end
  end

  desc "Extract entitlements file"
  lane :extract_entitlements do |options|
    # Substitute environment variables (with defaults) during extraction.
    # This makes the target entitlements file better suitable as artifact.
    File.write("../wallet_app/build/ios/Runner.entitlements",
      File.read("../wallet_app/ios/Runner/Runner.entitlements")
        .gsub(/\$\(([^:]+):default=([^)]+)\)/) do
          ENV[Regexp.last_match(1)] || Regexp.last_match(2)
        end.tap { |entitlements| UI.message("Entitlements: \n #{entitlements}") }
    )
  end

  desc "Sign iOS app"
  lane :sign do |options|

    bundle_id = options[:bundle_id] || get_app_identifier
    export_method = options[:app_store] ? "app-store" : "ad-hoc"
    match_type = export_method.sub('-', '')

    # Check for build artifacts
    UI.user_error!("Runner.xcarchive build artifact not found") unless File.exist?("../wallet_app/build/ios/archive/Runner.xcarchive")
    UI.user_error!("Runner.entitlements build artifact not found") unless File.exist?("../wallet_app/build/ios/Runner.entitlements")

    # Get default bundle id and version
    info = CFPropertyList.native_types(
      CFPropertyList::List::new(file: '../wallet_app/build/ios/archive/Runner.xcarchive/Info.plist').value
    )
    version = info["ApplicationProperties"]["CFBundleShortVersionString"]
    default_bundle_id = info["ApplicationProperties"]["CFBundleIdentifier"]

    # Info
    UI.message("Going to sign iOS build with bundle id #{bundle_id} and version #{version} with export method #{export_method}")

    # Set up provisioning profiles using match
    match(
      type: match_type,
      app_identifier: [bundle_id, default_bundle_id].uniq,
      clone_branch_directly: true,
      readonly: true,
    )

    # No brew installed rsync allowed in path to use xcodebuild -exportArchive
    # See https://github.com/fastlane/fastlane/issues/29528
    if sh('command', '-v', 'rsync').rstrip != "/usr/bin/rsync"
      UI.important("Putting /usr/bin in front of PATH to force use of Apple rsync")
      old_path = ENV['PATH']
      ENV['PATH'] = "/usr/bin/:#{ENV['PATH']}"
    else
      old_path = nil
    end

    # Create an .ipa file from the archive produce by Flutter
    ipa_file = "#{bundle_id}-#{version}.ipa"
    build_app(
      skip_build_archive: true,
      archive_path: "wallet_app/build/ios/archive/Runner.xcarchive",
      codesigning_identity: "iPhone Distribution",
      export_method: export_method,
      export_options: {
        provisioningProfiles: {
          default_bundle_id => Actions.lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING][default_bundle_id],
        }
      },
      output_name: ipa_file,
    )

    # Restoring path
    if old_path
      UI.important("Restoring PATH")
      ENV['PATH'] = old_path
    end

    # This should be enough but unfortunately xcodebuild -exportArchive does
    # not merge entitlements when creating an ipa from an xcarchive.
    # See https://github.com/fastlane/fastlane/issues/21224#issuecomment-2671522132
    # Simplest solution is to resign the ipa where we can specify the entitlements

    # Merging entitlements from ipa with the extra entitlements set in project
    app_entitlements = File.read('../wallet_app/build/ios/Runner.entitlements')
    ipa_entitlements = Dir.mktmpdir('nl-wallet-ipa') do |tmp_path|
      sh('unzip', '-qd', tmp_path, "../#{ipa_file}")
      # `codesign -d --entitlements - Runner.app --xml` extracts the entitlements of the app
      # and outputs the XML on a single line (last line) after some other output.
      sh('codesign', '-d', '--entitlements', '-', "#{tmp_path}/Payload/Runner.app", '--xml').rstrip.split("\n")[-1]
    end
    [app_entitlements, ipa_entitlements].map do |xml|
      CFPropertyList.native_types(CFPropertyList::List::new(data: xml).value)
    end.reduce(:merge).tap do |result|
      # resign does not update application identifier in entitlements if we force a specific entitlements
      result['application-identifier'] = result['com.apple.developer.team-identifier'] + "." + bundle_id
      File.write('entitlements.plist', result.to_plist(plist_format: CFPropertyList::List::FORMAT_XML))
    end

    # Resign with merged entitlements and different bundle id
    resign(
      ipa: ipa_file,
      entitlements: "fastlane/entitlements.plist",
      bundle_id: bundle_id,
      signing_identity: ENV["sigh_#{bundle_id}_#{match_type}_certificate-name"],
      provisioning_profile: ENV["sigh_#{bundle_id}_#{match_type}_profile-path"],
    )
  end

  desc "Deploy iOS app"
  lane :deploy do |options|
    bundle_id = options[:bundle_id] || get_app_identifier
    UI.user_error!("No bundle id given") if bundle_id.blank?

    upload_to_testflight(skip_submission: true, app_identifier: bundle_id)
  end

  desc "Upload iOS app to BrowserStack"
  lane :browserstack do |options|
    ipa_file = options[:ipa_file]
    user = options[:user]
    key = options[:key]

    upload_to_browserstack(file: ipa_file, user: user, key: key, custom_id: "NLWalletIos")
  end

  desc "Upload iOS app to BrowserStack from GitLab CI"
  lane :ci_browserstack do |options|
    browserstack_user = ENV["BROWSERSTACK_USER"]
    browserstack_key  = ENV["BROWSERSTACK_KEY"]
    commit_sha        = ENV["CI_COMMIT_SHA"]

    UI.user_error!("No BROWSERSTACK_USER environment variable set") if browserstack_user.blank?
    UI.user_error!("No BROWSERSTACK_KEY environment variable set")  if browserstack_key.blank?

    bundle_id = options[:bundle_id] || get_app_identifier
    UI.user_error!("No bundle id set") if bundle_id.blank?

    real_version, _ = get_local_version_and_build

    ipa_basename = "#{bundle_id}-#{real_version}.ipa"
    ipa_path_from_repo_root = "#{ipa_basename}"

    label = options[:label] || options[:version] #

    custom_id_parts = ["NLWalletIos", bundle_id]
    custom_id_parts << commit_sha unless commit_sha.to_s.empty?
    custom_id_parts << label unless label.to_s.empty?
    custom_id = custom_id_parts.join("_")

    unless File.exist?("../#{ipa_path_from_repo_root}")
      UI.user_error!("IPA not found at #{ipa_path_from_repo_root}. Make sure build_app produced #{ipa_basename} in fastlane/.")
    end

    upload_to_browserstack(
      file: ipa_path_from_repo_root,
      user: browserstack_user,
      key:  browserstack_key,
      custom_id: custom_id
    )
  end
end
