// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/full.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart' if (dart.library.js_interop) 'frb_generated.web.dart';
import 'models/attestation.dart';
import 'models/config.dart';
import 'models/disclosure.dart';
import 'models/instruction.dart';
import 'models/localize.dart';
import 'models/pin.dart';
import 'models/uri.dart';
import 'models/version_state.dart';
import 'models/wallet_event.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class WalletCore extends BaseEntrypoint<WalletCoreApi, WalletCoreApiImpl, WalletCoreWire> {
  @internal
  static final instance = WalletCore._();

  WalletCore._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    WalletCoreApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required WalletCoreApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<WalletCoreApiImpl, WalletCoreWire> get apiImplConstructor => WalletCoreApiImpl.new;

  @override
  WireConstructor<WalletCoreWire> get wireConstructor => WalletCoreWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiFullInit();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig => kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.9.0';

  @override
  int get rustContentHash => 1458509282;

  static const kDefaultExternalLibraryLoaderConfig = ExternalLibraryLoaderConfig(
    stem: 'wallet_core',
    ioDirectory: '../../../wallet_core/flutter_api/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class WalletCoreApi extends BaseApi {
  Future<AcceptDisclosureResult> crateApiFullAcceptDisclosure({required String pin});

  Future<WalletInstructionResult> crateApiFullAcceptPidIssuance({required String pin});

  Future<String?> crateApiFullCancelDisclosure();

  Future<void> crateApiFullCancelPidIssuance();

  Future<WalletInstructionResult> crateApiFullChangePin({required String oldPin, required String newPin});

  Future<WalletInstructionResult> crateApiFullCheckPin({required String pin});

  Future<void> crateApiFullClearAttestationsStream();

  Future<void> crateApiFullClearConfigurationStream();

  Future<void> crateApiFullClearLockStream();

  Future<void> crateApiFullClearRecentHistoryStream();

  Future<void> crateApiFullClearVersionStateStream();

  Future<WalletInstructionResult> crateApiFullContinueChangePin({required String pin});

  Future<List<Attestation>> crateApiFullContinuePidIssuance({required String uri});

  Future<String> crateApiFullCreatePidIssuanceRedirectUri();

  Future<List<WalletEvent>> crateApiFullGetHistory();

  Future<List<WalletEvent>> crateApiFullGetHistoryForCard({required String attestationType});

  Future<String> crateApiFullGetVersionString();

  Future<bool> crateApiFullHasActiveDisclosureSession();

  Future<bool> crateApiFullHasActivePidIssuanceSession();

  Future<bool> crateApiFullHasRegistration();

  Future<IdentifyUriResult> crateApiFullIdentifyUri({required String uri});

  Future<void> crateApiFullInit();

  Future<bool> crateApiFullIsBiometricUnlockEnabled();

  Future<bool> crateApiFullIsInitialized();

  Future<PinValidationResult> crateApiFullIsValidPin({required String pin});

  Future<void> crateApiFullLockWallet();

  Future<void> crateApiFullRegister({required String pin});

  Future<void> crateApiFullResetWallet();

  Stream<List<Attestation>> crateApiFullSetAttestationsStream();

  Future<void> crateApiFullSetBiometricUnlock({required bool enable});

  Stream<FlutterConfiguration> crateApiFullSetConfigurationStream();

  Stream<bool> crateApiFullSetLockStream();

  Stream<List<WalletEvent>> crateApiFullSetRecentHistoryStream();

  Stream<FlutterVersionState> crateApiFullSetVersionStateStream();

  Future<StartDisclosureResult> crateApiFullStartDisclosure({required String uri, required bool isQrCode});

  Future<WalletInstructionResult> crateApiFullUnlockWallet({required String pin});

  Future<void> crateApiFullUnlockWalletWithBiometrics();
}

class WalletCoreApiImpl extends WalletCoreApiImplPlatform implements WalletCoreApi {
  WalletCoreApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<AcceptDisclosureResult> crateApiFullAcceptDisclosure({required String pin}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(pin);
        return wire.wire__crate__api__full__accept_disclosure(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_accept_disclosure_result,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullAcceptDisclosureConstMeta,
      argValues: [pin],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullAcceptDisclosureConstMeta => const TaskConstMeta(
        debugName: "accept_disclosure",
        argNames: ["pin"],
      );

  @override
  Future<WalletInstructionResult> crateApiFullAcceptPidIssuance({required String pin}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(pin);
        return wire.wire__crate__api__full__accept_pid_issuance(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_wallet_instruction_result,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullAcceptPidIssuanceConstMeta,
      argValues: [pin],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullAcceptPidIssuanceConstMeta => const TaskConstMeta(
        debugName: "accept_pid_issuance",
        argNames: ["pin"],
      );

  @override
  Future<String?> crateApiFullCancelDisclosure() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__cancel_disclosure(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_String,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullCancelDisclosureConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullCancelDisclosureConstMeta => const TaskConstMeta(
        debugName: "cancel_disclosure",
        argNames: [],
      );

  @override
  Future<void> crateApiFullCancelPidIssuance() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__cancel_pid_issuance(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullCancelPidIssuanceConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullCancelPidIssuanceConstMeta => const TaskConstMeta(
        debugName: "cancel_pid_issuance",
        argNames: [],
      );

  @override
  Future<WalletInstructionResult> crateApiFullChangePin({required String oldPin, required String newPin}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(oldPin);
        var arg1 = cst_encode_String(newPin);
        return wire.wire__crate__api__full__change_pin(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_wallet_instruction_result,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullChangePinConstMeta,
      argValues: [oldPin, newPin],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullChangePinConstMeta => const TaskConstMeta(
        debugName: "change_pin",
        argNames: ["oldPin", "newPin"],
      );

  @override
  Future<WalletInstructionResult> crateApiFullCheckPin({required String pin}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(pin);
        return wire.wire__crate__api__full__check_pin(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_wallet_instruction_result,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullCheckPinConstMeta,
      argValues: [pin],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullCheckPinConstMeta => const TaskConstMeta(
        debugName: "check_pin",
        argNames: ["pin"],
      );

  @override
  Future<void> crateApiFullClearAttestationsStream() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__clear_attestations_stream(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullClearAttestationsStreamConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullClearAttestationsStreamConstMeta => const TaskConstMeta(
        debugName: "clear_attestations_stream",
        argNames: [],
      );

  @override
  Future<void> crateApiFullClearConfigurationStream() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__clear_configuration_stream(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullClearConfigurationStreamConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullClearConfigurationStreamConstMeta => const TaskConstMeta(
        debugName: "clear_configuration_stream",
        argNames: [],
      );

  @override
  Future<void> crateApiFullClearLockStream() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__clear_lock_stream(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullClearLockStreamConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullClearLockStreamConstMeta => const TaskConstMeta(
        debugName: "clear_lock_stream",
        argNames: [],
      );

  @override
  Future<void> crateApiFullClearRecentHistoryStream() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__clear_recent_history_stream(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullClearRecentHistoryStreamConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullClearRecentHistoryStreamConstMeta => const TaskConstMeta(
        debugName: "clear_recent_history_stream",
        argNames: [],
      );

  @override
  Future<void> crateApiFullClearVersionStateStream() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__clear_version_state_stream(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullClearVersionStateStreamConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullClearVersionStateStreamConstMeta => const TaskConstMeta(
        debugName: "clear_version_state_stream",
        argNames: [],
      );

  @override
  Future<WalletInstructionResult> crateApiFullContinueChangePin({required String pin}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(pin);
        return wire.wire__crate__api__full__continue_change_pin(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_wallet_instruction_result,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullContinueChangePinConstMeta,
      argValues: [pin],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullContinueChangePinConstMeta => const TaskConstMeta(
        debugName: "continue_change_pin",
        argNames: ["pin"],
      );

  @override
  Future<List<Attestation>> crateApiFullContinuePidIssuance({required String uri}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(uri);
        return wire.wire__crate__api__full__continue_pid_issuance(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_attestation,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullContinuePidIssuanceConstMeta,
      argValues: [uri],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullContinuePidIssuanceConstMeta => const TaskConstMeta(
        debugName: "continue_pid_issuance",
        argNames: ["uri"],
      );

  @override
  Future<String> crateApiFullCreatePidIssuanceRedirectUri() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__create_pid_issuance_redirect_uri(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullCreatePidIssuanceRedirectUriConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullCreatePidIssuanceRedirectUriConstMeta => const TaskConstMeta(
        debugName: "create_pid_issuance_redirect_uri",
        argNames: [],
      );

  @override
  Future<List<WalletEvent>> crateApiFullGetHistory() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__get_history(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_wallet_event,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullGetHistoryConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullGetHistoryConstMeta => const TaskConstMeta(
        debugName: "get_history",
        argNames: [],
      );

  @override
  Future<List<WalletEvent>> crateApiFullGetHistoryForCard({required String attestationType}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(attestationType);
        return wire.wire__crate__api__full__get_history_for_card(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_wallet_event,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullGetHistoryForCardConstMeta,
      argValues: [attestationType],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullGetHistoryForCardConstMeta => const TaskConstMeta(
        debugName: "get_history_for_card",
        argNames: ["attestationType"],
      );

  @override
  Future<String> crateApiFullGetVersionString() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__get_version_string(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullGetVersionStringConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullGetVersionStringConstMeta => const TaskConstMeta(
        debugName: "get_version_string",
        argNames: [],
      );

  @override
  Future<bool> crateApiFullHasActiveDisclosureSession() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__has_active_disclosure_session(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullHasActiveDisclosureSessionConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullHasActiveDisclosureSessionConstMeta => const TaskConstMeta(
        debugName: "has_active_disclosure_session",
        argNames: [],
      );

  @override
  Future<bool> crateApiFullHasActivePidIssuanceSession() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__has_active_pid_issuance_session(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullHasActivePidIssuanceSessionConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullHasActivePidIssuanceSessionConstMeta => const TaskConstMeta(
        debugName: "has_active_pid_issuance_session",
        argNames: [],
      );

  @override
  Future<bool> crateApiFullHasRegistration() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__has_registration(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullHasRegistrationConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullHasRegistrationConstMeta => const TaskConstMeta(
        debugName: "has_registration",
        argNames: [],
      );

  @override
  Future<IdentifyUriResult> crateApiFullIdentifyUri({required String uri}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(uri);
        return wire.wire__crate__api__full__identify_uri(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_identify_uri_result,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullIdentifyUriConstMeta,
      argValues: [uri],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullIdentifyUriConstMeta => const TaskConstMeta(
        debugName: "identify_uri",
        argNames: ["uri"],
      );

  @override
  Future<void> crateApiFullInit() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__init(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullInitConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullInitConstMeta => const TaskConstMeta(
        debugName: "init",
        argNames: [],
      );

  @override
  Future<bool> crateApiFullIsBiometricUnlockEnabled() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__is_biometric_unlock_enabled(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullIsBiometricUnlockEnabledConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullIsBiometricUnlockEnabledConstMeta => const TaskConstMeta(
        debugName: "is_biometric_unlock_enabled",
        argNames: [],
      );

  @override
  Future<bool> crateApiFullIsInitialized() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__is_initialized(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullIsInitializedConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullIsInitializedConstMeta => const TaskConstMeta(
        debugName: "is_initialized",
        argNames: [],
      );

  @override
  Future<PinValidationResult> crateApiFullIsValidPin({required String pin}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(pin);
        return wire.wire__crate__api__full__is_valid_pin(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_pin_validation_result,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullIsValidPinConstMeta,
      argValues: [pin],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullIsValidPinConstMeta => const TaskConstMeta(
        debugName: "is_valid_pin",
        argNames: ["pin"],
      );

  @override
  Future<void> crateApiFullLockWallet() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__lock_wallet(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullLockWalletConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullLockWalletConstMeta => const TaskConstMeta(
        debugName: "lock_wallet",
        argNames: [],
      );

  @override
  Future<void> crateApiFullRegister({required String pin}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(pin);
        return wire.wire__crate__api__full__register(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullRegisterConstMeta,
      argValues: [pin],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullRegisterConstMeta => const TaskConstMeta(
        debugName: "register",
        argNames: ["pin"],
      );

  @override
  Future<void> crateApiFullResetWallet() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__reset_wallet(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullResetWalletConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullResetWalletConstMeta => const TaskConstMeta(
        debugName: "reset_wallet",
        argNames: [],
      );

  @override
  Stream<List<Attestation>> crateApiFullSetAttestationsStream() {
    final sink = RustStreamSink<List<Attestation>>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_StreamSink_list_attestation_Dco(sink);
        return wire.wire__crate__api__full__set_attestations_stream(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullSetAttestationsStreamConstMeta,
      argValues: [sink],
      apiImpl: this,
    )));
    return sink.stream;
  }

  TaskConstMeta get kCrateApiFullSetAttestationsStreamConstMeta => const TaskConstMeta(
        debugName: "set_attestations_stream",
        argNames: ["sink"],
      );

  @override
  Future<void> crateApiFullSetBiometricUnlock({required bool enable}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_bool(enable);
        return wire.wire__crate__api__full__set_biometric_unlock(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullSetBiometricUnlockConstMeta,
      argValues: [enable],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullSetBiometricUnlockConstMeta => const TaskConstMeta(
        debugName: "set_biometric_unlock",
        argNames: ["enable"],
      );

  @override
  Stream<FlutterConfiguration> crateApiFullSetConfigurationStream() {
    final sink = RustStreamSink<FlutterConfiguration>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_StreamSink_flutter_configuration_Dco(sink);
        return wire.wire__crate__api__full__set_configuration_stream(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullSetConfigurationStreamConstMeta,
      argValues: [sink],
      apiImpl: this,
    )));
    return sink.stream;
  }

  TaskConstMeta get kCrateApiFullSetConfigurationStreamConstMeta => const TaskConstMeta(
        debugName: "set_configuration_stream",
        argNames: ["sink"],
      );

  @override
  Stream<bool> crateApiFullSetLockStream() {
    final sink = RustStreamSink<bool>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_StreamSink_bool_Dco(sink);
        return wire.wire__crate__api__full__set_lock_stream(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullSetLockStreamConstMeta,
      argValues: [sink],
      apiImpl: this,
    )));
    return sink.stream;
  }

  TaskConstMeta get kCrateApiFullSetLockStreamConstMeta => const TaskConstMeta(
        debugName: "set_lock_stream",
        argNames: ["sink"],
      );

  @override
  Stream<List<WalletEvent>> crateApiFullSetRecentHistoryStream() {
    final sink = RustStreamSink<List<WalletEvent>>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_StreamSink_list_wallet_event_Dco(sink);
        return wire.wire__crate__api__full__set_recent_history_stream(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullSetRecentHistoryStreamConstMeta,
      argValues: [sink],
      apiImpl: this,
    )));
    return sink.stream;
  }

  TaskConstMeta get kCrateApiFullSetRecentHistoryStreamConstMeta => const TaskConstMeta(
        debugName: "set_recent_history_stream",
        argNames: ["sink"],
      );

  @override
  Stream<FlutterVersionState> crateApiFullSetVersionStateStream() {
    final sink = RustStreamSink<FlutterVersionState>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_StreamSink_flutter_version_state_Dco(sink);
        return wire.wire__crate__api__full__set_version_state_stream(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullSetVersionStateStreamConstMeta,
      argValues: [sink],
      apiImpl: this,
    )));
    return sink.stream;
  }

  TaskConstMeta get kCrateApiFullSetVersionStateStreamConstMeta => const TaskConstMeta(
        debugName: "set_version_state_stream",
        argNames: ["sink"],
      );

  @override
  Future<StartDisclosureResult> crateApiFullStartDisclosure({required String uri, required bool isQrCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(uri);
        var arg1 = cst_encode_bool(isQrCode);
        return wire.wire__crate__api__full__start_disclosure(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_start_disclosure_result,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullStartDisclosureConstMeta,
      argValues: [uri, isQrCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullStartDisclosureConstMeta => const TaskConstMeta(
        debugName: "start_disclosure",
        argNames: ["uri", "isQrCode"],
      );

  @override
  Future<WalletInstructionResult> crateApiFullUnlockWallet({required String pin}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(pin);
        return wire.wire__crate__api__full__unlock_wallet(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_wallet_instruction_result,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullUnlockWalletConstMeta,
      argValues: [pin],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullUnlockWalletConstMeta => const TaskConstMeta(
        debugName: "unlock_wallet",
        argNames: ["pin"],
      );

  @override
  Future<void> crateApiFullUnlockWalletWithBiometrics() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__unlock_wallet_with_biometrics(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullUnlockWalletWithBiometricsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullUnlockWalletWithBiometricsConstMeta => const TaskConstMeta(
        debugName: "unlock_wallet_with_biometrics",
        argNames: [],
      );

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  RustStreamSink<bool> dco_decode_StreamSink_bool_Dco(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<FlutterConfiguration> dco_decode_StreamSink_flutter_configuration_Dco(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<FlutterVersionState> dco_decode_StreamSink_flutter_version_state_Dco(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<List<Attestation>> dco_decode_StreamSink_list_attestation_Dco(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<List<WalletEvent>> dco_decode_StreamSink_list_wallet_event_Dco(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AcceptDisclosureResult dco_decode_accept_disclosure_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return AcceptDisclosureResult_Ok(
          returnUrl: dco_decode_opt_String(raw[1]),
        );
      case 1:
        return AcceptDisclosureResult_InstructionError(
          error: dco_decode_box_autoadd_wallet_instruction_error(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Attestation dco_decode_attestation(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return Attestation(
      identity: dco_decode_attestation_identity(arr[0]),
      attestationType: dco_decode_String(arr[1]),
      displayMetadata: dco_decode_list_display_metadata(arr[2]),
      issuer: dco_decode_organization(arr[3]),
      attributes: dco_decode_list_attestation_attribute(arr[4]),
    );
  }

  @protected
  AttestationAttribute dco_decode_attestation_attribute(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return AttestationAttribute(
      key: dco_decode_String(arr[0]),
      labels: dco_decode_list_claim_display_metadata(arr[1]),
      value: dco_decode_attribute_value(arr[2]),
    );
  }

  @protected
  AttestationIdentity dco_decode_attestation_identity(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return AttestationIdentity_Ephemeral();
      case 1:
        return AttestationIdentity_Fixed(
          id: dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  AttributeValue dco_decode_attribute_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return AttributeValue_String(
          value: dco_decode_String(raw[1]),
        );
      case 1:
        return AttributeValue_Boolean(
          value: dco_decode_bool(raw[1]),
        );
      case 2:
        return AttributeValue_Number(
          value: dco_decode_i_64(raw[1]),
        );
      case 3:
        return AttributeValue_Date(
          value: dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  Attestation dco_decode_box_autoadd_attestation(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_attestation(raw);
  }

  @protected
  Image dco_decode_box_autoadd_image(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_image(raw);
  }

  @protected
  LogoMetadata dco_decode_box_autoadd_logo_metadata(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_logo_metadata(raw);
  }

  @protected
  Organization dco_decode_box_autoadd_organization(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_organization(raw);
  }

  @protected
  RenderingMetadata dco_decode_box_autoadd_rendering_metadata(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rendering_metadata(raw);
  }

  @protected
  RequestPolicy dco_decode_box_autoadd_request_policy(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_request_policy(raw);
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  WalletInstructionError dco_decode_box_autoadd_wallet_instruction_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_wallet_instruction_error(raw);
  }

  @protected
  ClaimDisplayMetadata dco_decode_claim_display_metadata(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ClaimDisplayMetadata(
      lang: dco_decode_String(arr[0]),
      label: dco_decode_String(arr[1]),
      description: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  DisclosureSessionType dco_decode_disclosure_session_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DisclosureSessionType.values[raw as int];
  }

  @protected
  DisclosureStatus dco_decode_disclosure_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DisclosureStatus.values[raw as int];
  }

  @protected
  DisclosureType dco_decode_disclosure_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DisclosureType.values[raw as int];
  }

  @protected
  DisplayMetadata dco_decode_display_metadata(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return DisplayMetadata(
      lang: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      description: dco_decode_opt_String(arr[2]),
      summary: dco_decode_opt_String(arr[3]),
      rendering: dco_decode_opt_box_autoadd_rendering_metadata(arr[4]),
    );
  }

  @protected
  FlutterConfiguration dco_decode_flutter_configuration(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return FlutterConfiguration(
      inactiveLockTimeout: dco_decode_u_16(arr[0]),
      backgroundLockTimeout: dco_decode_u_16(arr[1]),
      version: dco_decode_u_64(arr[2]),
    );
  }

  @protected
  FlutterVersionState dco_decode_flutter_version_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return FlutterVersionState_Ok();
      case 1:
        return FlutterVersionState_Notify();
      case 2:
        return FlutterVersionState_Recommend();
      case 3:
        return FlutterVersionState_Warn(
          expiresInSeconds: dco_decode_u_64(raw[1]),
        );
      case 4:
        return FlutterVersionState_Block();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  IdentifyUriResult dco_decode_identify_uri_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return IdentifyUriResult.values[raw as int];
  }

  @protected
  Image dco_decode_image(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Image_Svg(
          xml: dco_decode_String(raw[1]),
        );
      case 1:
        return Image_Png(
          base64: dco_decode_String(raw[1]),
        );
      case 2:
        return Image_Jpg(
          base64: dco_decode_String(raw[1]),
        );
      case 3:
        return Image_Asset(
          path: dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  List<Attestation> dco_decode_list_attestation(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_attestation).toList();
  }

  @protected
  List<AttestationAttribute> dco_decode_list_attestation_attribute(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_attestation_attribute).toList();
  }

  @protected
  List<ClaimDisplayMetadata> dco_decode_list_claim_display_metadata(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_claim_display_metadata).toList();
  }

  @protected
  List<DisplayMetadata> dco_decode_list_display_metadata(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_display_metadata).toList();
  }

  @protected
  List<LocalizedString> dco_decode_list_localized_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_localized_string).toList();
  }

  @protected
  List<MissingAttribute> dco_decode_list_missing_attribute(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_missing_attribute).toList();
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<WalletEvent> dco_decode_list_wallet_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_wallet_event).toList();
  }

  @protected
  LocalizedString dco_decode_localized_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return LocalizedString(
      language: dco_decode_String(arr[0]),
      value: dco_decode_String(arr[1]),
    );
  }

  @protected
  LogoMetadata dco_decode_logo_metadata(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return LogoMetadata(
      uri: dco_decode_String(arr[0]),
      uriIntegrity: dco_decode_String(arr[1]),
      altText: dco_decode_String(arr[2]),
    );
  }

  @protected
  MissingAttribute dco_decode_missing_attribute(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return MissingAttribute(
      labels: dco_decode_list_localized_string(arr[0]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  Image? dco_decode_opt_box_autoadd_image(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_image(raw);
  }

  @protected
  LogoMetadata? dco_decode_opt_box_autoadd_logo_metadata(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_logo_metadata(raw);
  }

  @protected
  RenderingMetadata? dco_decode_opt_box_autoadd_rendering_metadata(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_rendering_metadata(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  List<Attestation>? dco_decode_opt_list_attestation(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_attestation(raw);
  }

  @protected
  List<LocalizedString>? dco_decode_opt_list_localized_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_localized_string(raw);
  }

  @protected
  Organization dco_decode_organization(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11) throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return Organization(
      legalName: dco_decode_list_localized_string(arr[0]),
      displayName: dco_decode_list_localized_string(arr[1]),
      description: dco_decode_list_localized_string(arr[2]),
      image: dco_decode_opt_box_autoadd_image(arr[3]),
      webUrl: dco_decode_opt_String(arr[4]),
      privacyPolicyUrl: dco_decode_opt_String(arr[5]),
      kvk: dco_decode_opt_String(arr[6]),
      city: dco_decode_opt_list_localized_string(arr[7]),
      category: dco_decode_list_localized_string(arr[8]),
      department: dco_decode_opt_list_localized_string(arr[9]),
      countryCode: dco_decode_opt_String(arr[10]),
    );
  }

  @protected
  PinValidationResult dco_decode_pin_validation_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PinValidationResult.values[raw as int];
  }

  @protected
  RenderingMetadata dco_decode_rendering_metadata(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return RenderingMetadata_Simple(
          logo: dco_decode_opt_box_autoadd_logo_metadata(raw[1]),
          backgroundColor: dco_decode_opt_String(raw[2]),
          textColor: dco_decode_opt_String(raw[3]),
        );
      case 1:
        return RenderingMetadata_SvgTemplates();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  RequestPolicy dco_decode_request_policy(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return RequestPolicy(
      dataStorageDurationInMinutes: dco_decode_opt_box_autoadd_u_64(arr[0]),
      dataSharedWithThirdParties: dco_decode_bool(arr[1]),
      dataDeletionPossible: dco_decode_bool(arr[2]),
      policyUrl: dco_decode_String(arr[3]),
    );
  }

  @protected
  StartDisclosureResult dco_decode_start_disclosure_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return StartDisclosureResult_Request(
          relyingParty: dco_decode_box_autoadd_organization(raw[1]),
          policy: dco_decode_box_autoadd_request_policy(raw[2]),
          requestedAttestations: dco_decode_list_attestation(raw[3]),
          sharedDataWithRelyingPartyBefore: dco_decode_bool(raw[4]),
          sessionType: dco_decode_disclosure_session_type(raw[5]),
          requestPurpose: dco_decode_list_localized_string(raw[6]),
          requestOriginBaseUrl: dco_decode_String(raw[7]),
          requestType: dco_decode_disclosure_type(raw[8]),
        );
      case 1:
        return StartDisclosureResult_RequestAttributesMissing(
          relyingParty: dco_decode_box_autoadd_organization(raw[1]),
          missingAttributes: dco_decode_list_missing_attribute(raw[2]),
          sharedDataWithRelyingPartyBefore: dco_decode_bool(raw[3]),
          sessionType: dco_decode_disclosure_session_type(raw[4]),
          requestPurpose: dco_decode_list_localized_string(raw[5]),
          requestOriginBaseUrl: dco_decode_String(raw[6]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  WalletEvent dco_decode_wallet_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return WalletEvent_Disclosure(
          dateTime: dco_decode_String(raw[1]),
          relyingParty: dco_decode_box_autoadd_organization(raw[2]),
          purpose: dco_decode_list_localized_string(raw[3]),
          sharedAttestations: dco_decode_opt_list_attestation(raw[4]),
          requestPolicy: dco_decode_box_autoadd_request_policy(raw[5]),
          status: dco_decode_disclosure_status(raw[6]),
          typ: dco_decode_disclosure_type(raw[7]),
        );
      case 1:
        return WalletEvent_Issuance(
          dateTime: dco_decode_String(raw[1]),
          attestation: dco_decode_box_autoadd_attestation(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  WalletInstructionError dco_decode_wallet_instruction_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return WalletInstructionError_IncorrectPin(
          attemptsLeftInRound: dco_decode_u_8(raw[1]),
          isFinalRound: dco_decode_bool(raw[2]),
        );
      case 1:
        return WalletInstructionError_Timeout(
          timeoutMillis: dco_decode_u_64(raw[1]),
        );
      case 2:
        return WalletInstructionError_Blocked();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  WalletInstructionResult dco_decode_wallet_instruction_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return WalletInstructionResult_Ok();
      case 1:
        return WalletInstructionResult_InstructionError(
          error: dco_decode_box_autoadd_wallet_instruction_error(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  RustStreamSink<bool> sse_decode_StreamSink_bool_Dco(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<FlutterConfiguration> sse_decode_StreamSink_flutter_configuration_Dco(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<FlutterVersionState> sse_decode_StreamSink_flutter_version_state_Dco(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<List<Attestation>> sse_decode_StreamSink_list_attestation_Dco(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<List<WalletEvent>> sse_decode_StreamSink_list_wallet_event_Dco(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AcceptDisclosureResult sse_decode_accept_disclosure_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_returnUrl = sse_decode_opt_String(deserializer);
        return AcceptDisclosureResult_Ok(returnUrl: var_returnUrl);
      case 1:
        var var_error = sse_decode_box_autoadd_wallet_instruction_error(deserializer);
        return AcceptDisclosureResult_InstructionError(error: var_error);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Attestation sse_decode_attestation(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_identity = sse_decode_attestation_identity(deserializer);
    var var_attestationType = sse_decode_String(deserializer);
    var var_displayMetadata = sse_decode_list_display_metadata(deserializer);
    var var_issuer = sse_decode_organization(deserializer);
    var var_attributes = sse_decode_list_attestation_attribute(deserializer);
    return Attestation(
        identity: var_identity,
        attestationType: var_attestationType,
        displayMetadata: var_displayMetadata,
        issuer: var_issuer,
        attributes: var_attributes);
  }

  @protected
  AttestationAttribute sse_decode_attestation_attribute(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_key = sse_decode_String(deserializer);
    var var_labels = sse_decode_list_claim_display_metadata(deserializer);
    var var_value = sse_decode_attribute_value(deserializer);
    return AttestationAttribute(key: var_key, labels: var_labels, value: var_value);
  }

  @protected
  AttestationIdentity sse_decode_attestation_identity(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return AttestationIdentity_Ephemeral();
      case 1:
        var var_id = sse_decode_String(deserializer);
        return AttestationIdentity_Fixed(id: var_id);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  AttributeValue sse_decode_attribute_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_value = sse_decode_String(deserializer);
        return AttributeValue_String(value: var_value);
      case 1:
        var var_value = sse_decode_bool(deserializer);
        return AttributeValue_Boolean(value: var_value);
      case 2:
        var var_value = sse_decode_i_64(deserializer);
        return AttributeValue_Number(value: var_value);
      case 3:
        var var_value = sse_decode_String(deserializer);
        return AttributeValue_Date(value: var_value);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  Attestation sse_decode_box_autoadd_attestation(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_attestation(deserializer));
  }

  @protected
  Image sse_decode_box_autoadd_image(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_image(deserializer));
  }

  @protected
  LogoMetadata sse_decode_box_autoadd_logo_metadata(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_logo_metadata(deserializer));
  }

  @protected
  Organization sse_decode_box_autoadd_organization(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_organization(deserializer));
  }

  @protected
  RenderingMetadata sse_decode_box_autoadd_rendering_metadata(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rendering_metadata(deserializer));
  }

  @protected
  RequestPolicy sse_decode_box_autoadd_request_policy(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_request_policy(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  WalletInstructionError sse_decode_box_autoadd_wallet_instruction_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_wallet_instruction_error(deserializer));
  }

  @protected
  ClaimDisplayMetadata sse_decode_claim_display_metadata(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_lang = sse_decode_String(deserializer);
    var var_label = sse_decode_String(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    return ClaimDisplayMetadata(lang: var_lang, label: var_label, description: var_description);
  }

  @protected
  DisclosureSessionType sse_decode_disclosure_session_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return DisclosureSessionType.values[inner];
  }

  @protected
  DisclosureStatus sse_decode_disclosure_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return DisclosureStatus.values[inner];
  }

  @protected
  DisclosureType sse_decode_disclosure_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return DisclosureType.values[inner];
  }

  @protected
  DisplayMetadata sse_decode_display_metadata(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_lang = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    var var_summary = sse_decode_opt_String(deserializer);
    var var_rendering = sse_decode_opt_box_autoadd_rendering_metadata(deserializer);
    return DisplayMetadata(
        lang: var_lang, name: var_name, description: var_description, summary: var_summary, rendering: var_rendering);
  }

  @protected
  FlutterConfiguration sse_decode_flutter_configuration(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_inactiveLockTimeout = sse_decode_u_16(deserializer);
    var var_backgroundLockTimeout = sse_decode_u_16(deserializer);
    var var_version = sse_decode_u_64(deserializer);
    return FlutterConfiguration(
        inactiveLockTimeout: var_inactiveLockTimeout,
        backgroundLockTimeout: var_backgroundLockTimeout,
        version: var_version);
  }

  @protected
  FlutterVersionState sse_decode_flutter_version_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return FlutterVersionState_Ok();
      case 1:
        return FlutterVersionState_Notify();
      case 2:
        return FlutterVersionState_Recommend();
      case 3:
        var var_expiresInSeconds = sse_decode_u_64(deserializer);
        return FlutterVersionState_Warn(expiresInSeconds: var_expiresInSeconds);
      case 4:
        return FlutterVersionState_Block();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  IdentifyUriResult sse_decode_identify_uri_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return IdentifyUriResult.values[inner];
  }

  @protected
  Image sse_decode_image(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_xml = sse_decode_String(deserializer);
        return Image_Svg(xml: var_xml);
      case 1:
        var var_base64 = sse_decode_String(deserializer);
        return Image_Png(base64: var_base64);
      case 2:
        var var_base64 = sse_decode_String(deserializer);
        return Image_Jpg(base64: var_base64);
      case 3:
        var var_path = sse_decode_String(deserializer);
        return Image_Asset(path: var_path);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  List<Attestation> sse_decode_list_attestation(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Attestation>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_attestation(deserializer));
    }
    return ans_;
  }

  @protected
  List<AttestationAttribute> sse_decode_list_attestation_attribute(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <AttestationAttribute>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_attestation_attribute(deserializer));
    }
    return ans_;
  }

  @protected
  List<ClaimDisplayMetadata> sse_decode_list_claim_display_metadata(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ClaimDisplayMetadata>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_claim_display_metadata(deserializer));
    }
    return ans_;
  }

  @protected
  List<DisplayMetadata> sse_decode_list_display_metadata(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DisplayMetadata>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_display_metadata(deserializer));
    }
    return ans_;
  }

  @protected
  List<LocalizedString> sse_decode_list_localized_string(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LocalizedString>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_localized_string(deserializer));
    }
    return ans_;
  }

  @protected
  List<MissingAttribute> sse_decode_list_missing_attribute(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MissingAttribute>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_missing_attribute(deserializer));
    }
    return ans_;
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<WalletEvent> sse_decode_list_wallet_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <WalletEvent>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_wallet_event(deserializer));
    }
    return ans_;
  }

  @protected
  LocalizedString sse_decode_localized_string(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_language = sse_decode_String(deserializer);
    var var_value = sse_decode_String(deserializer);
    return LocalizedString(language: var_language, value: var_value);
  }

  @protected
  LogoMetadata sse_decode_logo_metadata(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_uri = sse_decode_String(deserializer);
    var var_uriIntegrity = sse_decode_String(deserializer);
    var var_altText = sse_decode_String(deserializer);
    return LogoMetadata(uri: var_uri, uriIntegrity: var_uriIntegrity, altText: var_altText);
  }

  @protected
  MissingAttribute sse_decode_missing_attribute(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_labels = sse_decode_list_localized_string(deserializer);
    return MissingAttribute(labels: var_labels);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Image? sse_decode_opt_box_autoadd_image(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_image(deserializer));
    } else {
      return null;
    }
  }

  @protected
  LogoMetadata? sse_decode_opt_box_autoadd_logo_metadata(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_logo_metadata(deserializer));
    } else {
      return null;
    }
  }

  @protected
  RenderingMetadata? sse_decode_opt_box_autoadd_rendering_metadata(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_rendering_metadata(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<Attestation>? sse_decode_opt_list_attestation(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_attestation(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<LocalizedString>? sse_decode_opt_list_localized_string(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_localized_string(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Organization sse_decode_organization(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_legalName = sse_decode_list_localized_string(deserializer);
    var var_displayName = sse_decode_list_localized_string(deserializer);
    var var_description = sse_decode_list_localized_string(deserializer);
    var var_image = sse_decode_opt_box_autoadd_image(deserializer);
    var var_webUrl = sse_decode_opt_String(deserializer);
    var var_privacyPolicyUrl = sse_decode_opt_String(deserializer);
    var var_kvk = sse_decode_opt_String(deserializer);
    var var_city = sse_decode_opt_list_localized_string(deserializer);
    var var_category = sse_decode_list_localized_string(deserializer);
    var var_department = sse_decode_opt_list_localized_string(deserializer);
    var var_countryCode = sse_decode_opt_String(deserializer);
    return Organization(
        legalName: var_legalName,
        displayName: var_displayName,
        description: var_description,
        image: var_image,
        webUrl: var_webUrl,
        privacyPolicyUrl: var_privacyPolicyUrl,
        kvk: var_kvk,
        city: var_city,
        category: var_category,
        department: var_department,
        countryCode: var_countryCode);
  }

  @protected
  PinValidationResult sse_decode_pin_validation_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PinValidationResult.values[inner];
  }

  @protected
  RenderingMetadata sse_decode_rendering_metadata(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_logo = sse_decode_opt_box_autoadd_logo_metadata(deserializer);
        var var_backgroundColor = sse_decode_opt_String(deserializer);
        var var_textColor = sse_decode_opt_String(deserializer);
        return RenderingMetadata_Simple(logo: var_logo, backgroundColor: var_backgroundColor, textColor: var_textColor);
      case 1:
        return RenderingMetadata_SvgTemplates();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  RequestPolicy sse_decode_request_policy(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_dataStorageDurationInMinutes = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_dataSharedWithThirdParties = sse_decode_bool(deserializer);
    var var_dataDeletionPossible = sse_decode_bool(deserializer);
    var var_policyUrl = sse_decode_String(deserializer);
    return RequestPolicy(
        dataStorageDurationInMinutes: var_dataStorageDurationInMinutes,
        dataSharedWithThirdParties: var_dataSharedWithThirdParties,
        dataDeletionPossible: var_dataDeletionPossible,
        policyUrl: var_policyUrl);
  }

  @protected
  StartDisclosureResult sse_decode_start_disclosure_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_relyingParty = sse_decode_box_autoadd_organization(deserializer);
        var var_policy = sse_decode_box_autoadd_request_policy(deserializer);
        var var_requestedAttestations = sse_decode_list_attestation(deserializer);
        var var_sharedDataWithRelyingPartyBefore = sse_decode_bool(deserializer);
        var var_sessionType = sse_decode_disclosure_session_type(deserializer);
        var var_requestPurpose = sse_decode_list_localized_string(deserializer);
        var var_requestOriginBaseUrl = sse_decode_String(deserializer);
        var var_requestType = sse_decode_disclosure_type(deserializer);
        return StartDisclosureResult_Request(
            relyingParty: var_relyingParty,
            policy: var_policy,
            requestedAttestations: var_requestedAttestations,
            sharedDataWithRelyingPartyBefore: var_sharedDataWithRelyingPartyBefore,
            sessionType: var_sessionType,
            requestPurpose: var_requestPurpose,
            requestOriginBaseUrl: var_requestOriginBaseUrl,
            requestType: var_requestType);
      case 1:
        var var_relyingParty = sse_decode_box_autoadd_organization(deserializer);
        var var_missingAttributes = sse_decode_list_missing_attribute(deserializer);
        var var_sharedDataWithRelyingPartyBefore = sse_decode_bool(deserializer);
        var var_sessionType = sse_decode_disclosure_session_type(deserializer);
        var var_requestPurpose = sse_decode_list_localized_string(deserializer);
        var var_requestOriginBaseUrl = sse_decode_String(deserializer);
        return StartDisclosureResult_RequestAttributesMissing(
            relyingParty: var_relyingParty,
            missingAttributes: var_missingAttributes,
            sharedDataWithRelyingPartyBefore: var_sharedDataWithRelyingPartyBefore,
            sessionType: var_sessionType,
            requestPurpose: var_requestPurpose,
            requestOriginBaseUrl: var_requestOriginBaseUrl);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  WalletEvent sse_decode_wallet_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_dateTime = sse_decode_String(deserializer);
        var var_relyingParty = sse_decode_box_autoadd_organization(deserializer);
        var var_purpose = sse_decode_list_localized_string(deserializer);
        var var_sharedAttestations = sse_decode_opt_list_attestation(deserializer);
        var var_requestPolicy = sse_decode_box_autoadd_request_policy(deserializer);
        var var_status = sse_decode_disclosure_status(deserializer);
        var var_typ = sse_decode_disclosure_type(deserializer);
        return WalletEvent_Disclosure(
            dateTime: var_dateTime,
            relyingParty: var_relyingParty,
            purpose: var_purpose,
            sharedAttestations: var_sharedAttestations,
            requestPolicy: var_requestPolicy,
            status: var_status,
            typ: var_typ);
      case 1:
        var var_dateTime = sse_decode_String(deserializer);
        var var_attestation = sse_decode_box_autoadd_attestation(deserializer);
        return WalletEvent_Issuance(dateTime: var_dateTime, attestation: var_attestation);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  WalletInstructionError sse_decode_wallet_instruction_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_attemptsLeftInRound = sse_decode_u_8(deserializer);
        var var_isFinalRound = sse_decode_bool(deserializer);
        return WalletInstructionError_IncorrectPin(
            attemptsLeftInRound: var_attemptsLeftInRound, isFinalRound: var_isFinalRound);
      case 1:
        var var_timeoutMillis = sse_decode_u_64(deserializer);
        return WalletInstructionError_Timeout(timeoutMillis: var_timeoutMillis);
      case 2:
        return WalletInstructionError_Blocked();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  WalletInstructionResult sse_decode_wallet_instruction_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return WalletInstructionResult_Ok();
      case 1:
        var var_error = sse_decode_box_autoadd_wallet_instruction_error(deserializer);
        return WalletInstructionResult_InstructionError(error: var_error);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_disclosure_session_type(DisclosureSessionType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_disclosure_status(DisclosureStatus raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_disclosure_type(DisclosureType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_identify_uri_result(IdentifyUriResult raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_pin_validation_result(PinValidationResult raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_u_16(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void sse_encode_AnyhowException(AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_StreamSink_bool_Dco(RustStreamSink<bool> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: dco_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_flutter_configuration_Dco(
      RustStreamSink<FlutterConfiguration> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: DcoCodec(
          decodeSuccessData: dco_decode_flutter_configuration,
          decodeErrorData: dco_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_flutter_version_state_Dco(
      RustStreamSink<FlutterVersionState> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: DcoCodec(
          decodeSuccessData: dco_decode_flutter_version_state,
          decodeErrorData: dco_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_list_attestation_Dco(RustStreamSink<List<Attestation>> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: DcoCodec(
          decodeSuccessData: dco_decode_list_attestation,
          decodeErrorData: dco_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_list_wallet_event_Dco(RustStreamSink<List<WalletEvent>> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: DcoCodec(
          decodeSuccessData: dco_decode_list_wallet_event,
          decodeErrorData: dco_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_accept_disclosure_result(AcceptDisclosureResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case AcceptDisclosureResult_Ok(returnUrl: final returnUrl):
        sse_encode_i_32(0, serializer);
        sse_encode_opt_String(returnUrl, serializer);
      case AcceptDisclosureResult_InstructionError(error: final error):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_wallet_instruction_error(error, serializer);
    }
  }

  @protected
  void sse_encode_attestation(Attestation self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_attestation_identity(self.identity, serializer);
    sse_encode_String(self.attestationType, serializer);
    sse_encode_list_display_metadata(self.displayMetadata, serializer);
    sse_encode_organization(self.issuer, serializer);
    sse_encode_list_attestation_attribute(self.attributes, serializer);
  }

  @protected
  void sse_encode_attestation_attribute(AttestationAttribute self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.key, serializer);
    sse_encode_list_claim_display_metadata(self.labels, serializer);
    sse_encode_attribute_value(self.value, serializer);
  }

  @protected
  void sse_encode_attestation_identity(AttestationIdentity self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case AttestationIdentity_Ephemeral():
        sse_encode_i_32(0, serializer);
      case AttestationIdentity_Fixed(id: final id):
        sse_encode_i_32(1, serializer);
        sse_encode_String(id, serializer);
    }
  }

  @protected
  void sse_encode_attribute_value(AttributeValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case AttributeValue_String(value: final value):
        sse_encode_i_32(0, serializer);
        sse_encode_String(value, serializer);
      case AttributeValue_Boolean(value: final value):
        sse_encode_i_32(1, serializer);
        sse_encode_bool(value, serializer);
      case AttributeValue_Number(value: final value):
        sse_encode_i_32(2, serializer);
        sse_encode_i_64(value, serializer);
      case AttributeValue_Date(value: final value):
        sse_encode_i_32(3, serializer);
        sse_encode_String(value, serializer);
    }
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_attestation(Attestation self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_attestation(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_image(Image self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_image(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_logo_metadata(LogoMetadata self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_logo_metadata(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_organization(Organization self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_organization(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rendering_metadata(RenderingMetadata self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rendering_metadata(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_request_policy(RequestPolicy self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_request_policy(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_wallet_instruction_error(WalletInstructionError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_wallet_instruction_error(self, serializer);
  }

  @protected
  void sse_encode_claim_display_metadata(ClaimDisplayMetadata self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.lang, serializer);
    sse_encode_String(self.label, serializer);
    sse_encode_opt_String(self.description, serializer);
  }

  @protected
  void sse_encode_disclosure_session_type(DisclosureSessionType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_disclosure_status(DisclosureStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_disclosure_type(DisclosureType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_display_metadata(DisplayMetadata self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.lang, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_opt_String(self.description, serializer);
    sse_encode_opt_String(self.summary, serializer);
    sse_encode_opt_box_autoadd_rendering_metadata(self.rendering, serializer);
  }

  @protected
  void sse_encode_flutter_configuration(FlutterConfiguration self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_16(self.inactiveLockTimeout, serializer);
    sse_encode_u_16(self.backgroundLockTimeout, serializer);
    sse_encode_u_64(self.version, serializer);
  }

  @protected
  void sse_encode_flutter_version_state(FlutterVersionState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case FlutterVersionState_Ok():
        sse_encode_i_32(0, serializer);
      case FlutterVersionState_Notify():
        sse_encode_i_32(1, serializer);
      case FlutterVersionState_Recommend():
        sse_encode_i_32(2, serializer);
      case FlutterVersionState_Warn(expiresInSeconds: final expiresInSeconds):
        sse_encode_i_32(3, serializer);
        sse_encode_u_64(expiresInSeconds, serializer);
      case FlutterVersionState_Block():
        sse_encode_i_32(4, serializer);
    }
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_identify_uri_result(IdentifyUriResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_image(Image self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Image_Svg(xml: final xml):
        sse_encode_i_32(0, serializer);
        sse_encode_String(xml, serializer);
      case Image_Png(base64: final base64):
        sse_encode_i_32(1, serializer);
        sse_encode_String(base64, serializer);
      case Image_Jpg(base64: final base64):
        sse_encode_i_32(2, serializer);
        sse_encode_String(base64, serializer);
      case Image_Asset(path: final path):
        sse_encode_i_32(3, serializer);
        sse_encode_String(path, serializer);
    }
  }

  @protected
  void sse_encode_list_attestation(List<Attestation> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_attestation(item, serializer);
    }
  }

  @protected
  void sse_encode_list_attestation_attribute(List<AttestationAttribute> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_attestation_attribute(item, serializer);
    }
  }

  @protected
  void sse_encode_list_claim_display_metadata(List<ClaimDisplayMetadata> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_claim_display_metadata(item, serializer);
    }
  }

  @protected
  void sse_encode_list_display_metadata(List<DisplayMetadata> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_display_metadata(item, serializer);
    }
  }

  @protected
  void sse_encode_list_localized_string(List<LocalizedString> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_localized_string(item, serializer);
    }
  }

  @protected
  void sse_encode_list_missing_attribute(List<MissingAttribute> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_missing_attribute(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_strict(Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_wallet_event(List<WalletEvent> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_wallet_event(item, serializer);
    }
  }

  @protected
  void sse_encode_localized_string(LocalizedString self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.language, serializer);
    sse_encode_String(self.value, serializer);
  }

  @protected
  void sse_encode_logo_metadata(LogoMetadata self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.uri, serializer);
    sse_encode_String(self.uriIntegrity, serializer);
    sse_encode_String(self.altText, serializer);
  }

  @protected
  void sse_encode_missing_attribute(MissingAttribute self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_localized_string(self.labels, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_image(Image? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_image(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_logo_metadata(LogoMetadata? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_logo_metadata(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_rendering_metadata(RenderingMetadata? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_rendering_metadata(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_attestation(List<Attestation>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_attestation(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_localized_string(List<LocalizedString>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_localized_string(self, serializer);
    }
  }

  @protected
  void sse_encode_organization(Organization self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_localized_string(self.legalName, serializer);
    sse_encode_list_localized_string(self.displayName, serializer);
    sse_encode_list_localized_string(self.description, serializer);
    sse_encode_opt_box_autoadd_image(self.image, serializer);
    sse_encode_opt_String(self.webUrl, serializer);
    sse_encode_opt_String(self.privacyPolicyUrl, serializer);
    sse_encode_opt_String(self.kvk, serializer);
    sse_encode_opt_list_localized_string(self.city, serializer);
    sse_encode_list_localized_string(self.category, serializer);
    sse_encode_opt_list_localized_string(self.department, serializer);
    sse_encode_opt_String(self.countryCode, serializer);
  }

  @protected
  void sse_encode_pin_validation_result(PinValidationResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_rendering_metadata(RenderingMetadata self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case RenderingMetadata_Simple(
          logo: final logo,
          backgroundColor: final backgroundColor,
          textColor: final textColor
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_opt_box_autoadd_logo_metadata(logo, serializer);
        sse_encode_opt_String(backgroundColor, serializer);
        sse_encode_opt_String(textColor, serializer);
      case RenderingMetadata_SvgTemplates():
        sse_encode_i_32(1, serializer);
    }
  }

  @protected
  void sse_encode_request_policy(RequestPolicy self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_u_64(self.dataStorageDurationInMinutes, serializer);
    sse_encode_bool(self.dataSharedWithThirdParties, serializer);
    sse_encode_bool(self.dataDeletionPossible, serializer);
    sse_encode_String(self.policyUrl, serializer);
  }

  @protected
  void sse_encode_start_disclosure_result(StartDisclosureResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case StartDisclosureResult_Request(
          relyingParty: final relyingParty,
          policy: final policy,
          requestedAttestations: final requestedAttestations,
          sharedDataWithRelyingPartyBefore: final sharedDataWithRelyingPartyBefore,
          sessionType: final sessionType,
          requestPurpose: final requestPurpose,
          requestOriginBaseUrl: final requestOriginBaseUrl,
          requestType: final requestType
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_organization(relyingParty, serializer);
        sse_encode_box_autoadd_request_policy(policy, serializer);
        sse_encode_list_attestation(requestedAttestations, serializer);
        sse_encode_bool(sharedDataWithRelyingPartyBefore, serializer);
        sse_encode_disclosure_session_type(sessionType, serializer);
        sse_encode_list_localized_string(requestPurpose, serializer);
        sse_encode_String(requestOriginBaseUrl, serializer);
        sse_encode_disclosure_type(requestType, serializer);
      case StartDisclosureResult_RequestAttributesMissing(
          relyingParty: final relyingParty,
          missingAttributes: final missingAttributes,
          sharedDataWithRelyingPartyBefore: final sharedDataWithRelyingPartyBefore,
          sessionType: final sessionType,
          requestPurpose: final requestPurpose,
          requestOriginBaseUrl: final requestOriginBaseUrl
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_organization(relyingParty, serializer);
        sse_encode_list_missing_attribute(missingAttributes, serializer);
        sse_encode_bool(sharedDataWithRelyingPartyBefore, serializer);
        sse_encode_disclosure_session_type(sessionType, serializer);
        sse_encode_list_localized_string(requestPurpose, serializer);
        sse_encode_String(requestOriginBaseUrl, serializer);
    }
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_wallet_event(WalletEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case WalletEvent_Disclosure(
          dateTime: final dateTime,
          relyingParty: final relyingParty,
          purpose: final purpose,
          sharedAttestations: final sharedAttestations,
          requestPolicy: final requestPolicy,
          status: final status,
          typ: final typ
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_String(dateTime, serializer);
        sse_encode_box_autoadd_organization(relyingParty, serializer);
        sse_encode_list_localized_string(purpose, serializer);
        sse_encode_opt_list_attestation(sharedAttestations, serializer);
        sse_encode_box_autoadd_request_policy(requestPolicy, serializer);
        sse_encode_disclosure_status(status, serializer);
        sse_encode_disclosure_type(typ, serializer);
      case WalletEvent_Issuance(dateTime: final dateTime, attestation: final attestation):
        sse_encode_i_32(1, serializer);
        sse_encode_String(dateTime, serializer);
        sse_encode_box_autoadd_attestation(attestation, serializer);
    }
  }

  @protected
  void sse_encode_wallet_instruction_error(WalletInstructionError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case WalletInstructionError_IncorrectPin(
          attemptsLeftInRound: final attemptsLeftInRound,
          isFinalRound: final isFinalRound
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_u_8(attemptsLeftInRound, serializer);
        sse_encode_bool(isFinalRound, serializer);
      case WalletInstructionError_Timeout(timeoutMillis: final timeoutMillis):
        sse_encode_i_32(1, serializer);
        sse_encode_u_64(timeoutMillis, serializer);
      case WalletInstructionError_Blocked():
        sse_encode_i_32(2, serializer);
    }
  }

  @protected
  void sse_encode_wallet_instruction_result(WalletInstructionResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case WalletInstructionResult_Ok():
        sse_encode_i_32(0, serializer);
      case WalletInstructionResult_InstructionError(error: final error):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_wallet_instruction_error(error, serializer);
    }
  }
}
