// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.7.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'dart:async';
import 'dart:convert';

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

import 'api/full.dart';
import 'frb_generated.dart';
import 'frb_generated.io.dart' if (dart.library.js_interop) 'frb_generated.web.dart';
import 'models/card.dart';
import 'models/config.dart';
import 'models/disclosure.dart';
import 'models/instruction.dart';
import 'models/pin.dart';
import 'models/uri.dart';
import 'models/version_state.dart';
import 'models/wallet_event.dart';

/// Main entrypoint of the Rust API
class WalletCore extends BaseEntrypoint<WalletCoreApi, WalletCoreApiImpl, WalletCoreWire> {
  @internal
  static final instance = WalletCore._();

  WalletCore._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    WalletCoreApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required WalletCoreApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<WalletCoreApiImpl, WalletCoreWire> get apiImplConstructor => WalletCoreApiImpl.new;

  @override
  WireConstructor<WalletCoreWire> get wireConstructor => WalletCoreWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiFullInit();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig => kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.7.0';

  @override
  int get rustContentHash => -580739876;

  static const kDefaultExternalLibraryLoaderConfig = ExternalLibraryLoaderConfig(
    stem: 'wallet_core',
    ioDirectory: '../../../wallet_core/flutter_api/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class WalletCoreApi extends BaseApi {
  Future<AcceptDisclosureResult> crateApiFullAcceptDisclosure({required String pin});

  Future<WalletInstructionResult> crateApiFullAcceptPidIssuance({required String pin});

  Future<String?> crateApiFullCancelDisclosure();

  Future<void> crateApiFullCancelPidIssuance();

  Future<WalletInstructionResult> crateApiFullChangePin({required String oldPin, required String newPin});

  Future<WalletInstructionResult> crateApiFullCheckPin({required String pin});

  Future<void> crateApiFullClearCardsStream();

  Future<void> crateApiFullClearConfigurationStream();

  Future<void> crateApiFullClearLockStream();

  Future<void> crateApiFullClearRecentHistoryStream();

  Future<void> crateApiFullClearVersionStateStream();

  Future<WalletInstructionResult> crateApiFullContinueChangePin({required String pin});

  Future<List<Card>> crateApiFullContinuePidIssuance({required String uri});

  Future<String> crateApiFullCreatePidIssuanceRedirectUri();

  Future<List<WalletEvent>> crateApiFullGetHistory();

  Future<List<WalletEvent>> crateApiFullGetHistoryForCard({required String docType});

  Future<String> crateApiFullGetVersionString();

  Future<bool> crateApiFullHasActiveDisclosureSession();

  Future<bool> crateApiFullHasActivePidIssuanceSession();

  Future<bool> crateApiFullHasRegistration();

  Future<IdentifyUriResult> crateApiFullIdentifyUri({required String uri});

  Future<void> crateApiFullInit();

  Future<bool> crateApiFullIsBiometricUnlockEnabled();

  Future<bool> crateApiFullIsInitialized();

  Future<PinValidationResult> crateApiFullIsValidPin({required String pin});

  Future<void> crateApiFullLockWallet();

  Future<void> crateApiFullRegister({required String pin});

  Future<void> crateApiFullResetWallet();

  Future<void> crateApiFullSetBiometricUnlock({required bool enable});

  Stream<List<Card>> crateApiFullSetCardsStream();

  Stream<FlutterConfiguration> crateApiFullSetConfigurationStream();

  Stream<bool> crateApiFullSetLockStream();

  Stream<List<WalletEvent>> crateApiFullSetRecentHistoryStream();

  Stream<FlutterVersionState> crateApiFullSetVersionStateStream();

  Future<StartDisclosureResult> crateApiFullStartDisclosure({required String uri, required bool isQrCode});

  Future<WalletInstructionResult> crateApiFullUnlockWallet({required String pin});

  Future<void> crateApiFullUnlockWalletWithBiometrics();
}

class WalletCoreApiImpl extends WalletCoreApiImplPlatform implements WalletCoreApi {
  WalletCoreApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<AcceptDisclosureResult> crateApiFullAcceptDisclosure({required String pin}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(pin, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 1, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_accept_disclosure_result,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullAcceptDisclosureConstMeta,
        argValues: [pin],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullAcceptDisclosureConstMeta => const TaskConstMeta(
        debugName: 'accept_disclosure',
        argNames: ['pin'],
      );

  @override
  Future<WalletInstructionResult> crateApiFullAcceptPidIssuance({required String pin}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(pin, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 2, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_wallet_instruction_result,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullAcceptPidIssuanceConstMeta,
        argValues: [pin],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullAcceptPidIssuanceConstMeta => const TaskConstMeta(
        debugName: 'accept_pid_issuance',
        argNames: ['pin'],
      );

  @override
  Future<String?> crateApiFullCancelDisclosure() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullCancelDisclosureConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullCancelDisclosureConstMeta => const TaskConstMeta(
        debugName: 'cancel_disclosure',
        argNames: [],
      );

  @override
  Future<void> crateApiFullCancelPidIssuance() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 4, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullCancelPidIssuanceConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullCancelPidIssuanceConstMeta => const TaskConstMeta(
        debugName: 'cancel_pid_issuance',
        argNames: [],
      );

  @override
  Future<WalletInstructionResult> crateApiFullChangePin({required String oldPin, required String newPin}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(oldPin, serializer);
          sse_encode_String(newPin, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 5, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_wallet_instruction_result,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullChangePinConstMeta,
        argValues: [oldPin, newPin],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullChangePinConstMeta => const TaskConstMeta(
        debugName: 'change_pin',
        argNames: ['oldPin', 'newPin'],
      );

  @override
  Future<WalletInstructionResult> crateApiFullCheckPin({required String pin}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(pin, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 6, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_wallet_instruction_result,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullCheckPinConstMeta,
        argValues: [pin],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullCheckPinConstMeta => const TaskConstMeta(
        debugName: 'check_pin',
        argNames: ['pin'],
      );

  @override
  Future<void> crateApiFullClearCardsStream() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 7, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiFullClearCardsStreamConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullClearCardsStreamConstMeta => const TaskConstMeta(
        debugName: 'clear_cards_stream',
        argNames: [],
      );

  @override
  Future<void> crateApiFullClearConfigurationStream() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 8, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiFullClearConfigurationStreamConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullClearConfigurationStreamConstMeta => const TaskConstMeta(
        debugName: 'clear_configuration_stream',
        argNames: [],
      );

  @override
  Future<void> crateApiFullClearLockStream() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 9, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiFullClearLockStreamConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullClearLockStreamConstMeta => const TaskConstMeta(
        debugName: 'clear_lock_stream',
        argNames: [],
      );

  @override
  Future<void> crateApiFullClearRecentHistoryStream() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 10, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiFullClearRecentHistoryStreamConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullClearRecentHistoryStreamConstMeta => const TaskConstMeta(
        debugName: 'clear_recent_history_stream',
        argNames: [],
      );

  @override
  Future<void> crateApiFullClearVersionStateStream() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 11, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiFullClearVersionStateStreamConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullClearVersionStateStreamConstMeta => const TaskConstMeta(
        debugName: 'clear_version_state_stream',
        argNames: [],
      );

  @override
  Future<WalletInstructionResult> crateApiFullContinueChangePin({required String pin}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(pin, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 12, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_wallet_instruction_result,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullContinueChangePinConstMeta,
        argValues: [pin],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullContinueChangePinConstMeta => const TaskConstMeta(
        debugName: 'continue_change_pin',
        argNames: ['pin'],
      );

  @override
  Future<List<Card>> crateApiFullContinuePidIssuance({required String uri}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(uri, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 13, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_card,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullContinuePidIssuanceConstMeta,
        argValues: [uri],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullContinuePidIssuanceConstMeta => const TaskConstMeta(
        debugName: 'continue_pid_issuance',
        argNames: ['uri'],
      );

  @override
  Future<String> crateApiFullCreatePidIssuanceRedirectUri() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 14, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullCreatePidIssuanceRedirectUriConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullCreatePidIssuanceRedirectUriConstMeta => const TaskConstMeta(
        debugName: 'create_pid_issuance_redirect_uri',
        argNames: [],
      );

  @override
  Future<List<WalletEvent>> crateApiFullGetHistory() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 15, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_wallet_event,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullGetHistoryConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullGetHistoryConstMeta => const TaskConstMeta(
        debugName: 'get_history',
        argNames: [],
      );

  @override
  Future<List<WalletEvent>> crateApiFullGetHistoryForCard({required String docType}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(docType, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 16, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_wallet_event,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullGetHistoryForCardConstMeta,
        argValues: [docType],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullGetHistoryForCardConstMeta => const TaskConstMeta(
        debugName: 'get_history_for_card',
        argNames: ['docType'],
      );

  @override
  Future<String> crateApiFullGetVersionString() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 17, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiFullGetVersionStringConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullGetVersionStringConstMeta => const TaskConstMeta(
        debugName: 'get_version_string',
        argNames: [],
      );

  @override
  Future<bool> crateApiFullHasActiveDisclosureSession() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 18, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullHasActiveDisclosureSessionConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullHasActiveDisclosureSessionConstMeta => const TaskConstMeta(
        debugName: 'has_active_disclosure_session',
        argNames: [],
      );

  @override
  Future<bool> crateApiFullHasActivePidIssuanceSession() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 19, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullHasActivePidIssuanceSessionConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullHasActivePidIssuanceSessionConstMeta => const TaskConstMeta(
        debugName: 'has_active_pid_issuance_session',
        argNames: [],
      );

  @override
  Future<bool> crateApiFullHasRegistration() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 20, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiFullHasRegistrationConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullHasRegistrationConstMeta => const TaskConstMeta(
        debugName: 'has_registration',
        argNames: [],
      );

  @override
  Future<IdentifyUriResult> crateApiFullIdentifyUri({required String uri}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(uri, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 21, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_identify_uri_result,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullIdentifyUriConstMeta,
        argValues: [uri],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullIdentifyUriConstMeta => const TaskConstMeta(
        debugName: 'identify_uri',
        argNames: ['uri'],
      );

  @override
  Future<void> crateApiFullInit() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 22, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullInitConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullInitConstMeta => const TaskConstMeta(
        debugName: 'init',
        argNames: [],
      );

  @override
  Future<bool> crateApiFullIsBiometricUnlockEnabled() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 23, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullIsBiometricUnlockEnabledConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullIsBiometricUnlockEnabledConstMeta => const TaskConstMeta(
        debugName: 'is_biometric_unlock_enabled',
        argNames: [],
      );

  @override
  Future<bool> crateApiFullIsInitialized() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 24, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiFullIsInitializedConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullIsInitializedConstMeta => const TaskConstMeta(
        debugName: 'is_initialized',
        argNames: [],
      );

  @override
  Future<PinValidationResult> crateApiFullIsValidPin({required String pin}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(pin, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 25, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_pin_validation_result,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullIsValidPinConstMeta,
        argValues: [pin],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullIsValidPinConstMeta => const TaskConstMeta(
        debugName: 'is_valid_pin',
        argNames: ['pin'],
      );

  @override
  Future<void> crateApiFullLockWallet() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 26, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiFullLockWalletConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullLockWalletConstMeta => const TaskConstMeta(
        debugName: 'lock_wallet',
        argNames: [],
      );

  @override
  Future<void> crateApiFullRegister({required String pin}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(pin, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 27, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullRegisterConstMeta,
        argValues: [pin],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullRegisterConstMeta => const TaskConstMeta(
        debugName: 'register',
        argNames: ['pin'],
      );

  @override
  Future<void> crateApiFullResetWallet() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 28, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullResetWalletConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullResetWalletConstMeta => const TaskConstMeta(
        debugName: 'reset_wallet',
        argNames: [],
      );

  @override
  Future<void> crateApiFullSetBiometricUnlock({required bool enable}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_bool(enable, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 29, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullSetBiometricUnlockConstMeta,
        argValues: [enable],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullSetBiometricUnlockConstMeta => const TaskConstMeta(
        debugName: 'set_biometric_unlock',
        argNames: ['enable'],
      );

  @override
  Stream<List<Card>> crateApiFullSetCardsStream() {
    final sink = RustStreamSink<List<Card>>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_StreamSink_list_card_Sse(sink, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 30, port: port_);
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateApiFullSetCardsStreamConstMeta,
          argValues: [sink],
          apiImpl: this,
        ),
      ),
    );
    return sink.stream;
  }

  TaskConstMeta get kCrateApiFullSetCardsStreamConstMeta => const TaskConstMeta(
        debugName: 'set_cards_stream',
        argNames: ['sink'],
      );

  @override
  Stream<FlutterConfiguration> crateApiFullSetConfigurationStream() {
    final sink = RustStreamSink<FlutterConfiguration>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_StreamSink_flutter_configuration_Sse(sink, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 31, port: port_);
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: null,
          ),
          constMeta: kCrateApiFullSetConfigurationStreamConstMeta,
          argValues: [sink],
          apiImpl: this,
        ),
      ),
    );
    return sink.stream;
  }

  TaskConstMeta get kCrateApiFullSetConfigurationStreamConstMeta => const TaskConstMeta(
        debugName: 'set_configuration_stream',
        argNames: ['sink'],
      );

  @override
  Stream<bool> crateApiFullSetLockStream() {
    final sink = RustStreamSink<bool>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_StreamSink_bool_Sse(sink, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 32, port: port_);
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: null,
          ),
          constMeta: kCrateApiFullSetLockStreamConstMeta,
          argValues: [sink],
          apiImpl: this,
        ),
      ),
    );
    return sink.stream;
  }

  TaskConstMeta get kCrateApiFullSetLockStreamConstMeta => const TaskConstMeta(
        debugName: 'set_lock_stream',
        argNames: ['sink'],
      );

  @override
  Stream<List<WalletEvent>> crateApiFullSetRecentHistoryStream() {
    final sink = RustStreamSink<List<WalletEvent>>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_StreamSink_list_wallet_event_Sse(sink, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 33, port: port_);
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateApiFullSetRecentHistoryStreamConstMeta,
          argValues: [sink],
          apiImpl: this,
        ),
      ),
    );
    return sink.stream;
  }

  TaskConstMeta get kCrateApiFullSetRecentHistoryStreamConstMeta => const TaskConstMeta(
        debugName: 'set_recent_history_stream',
        argNames: ['sink'],
      );

  @override
  Stream<FlutterVersionState> crateApiFullSetVersionStateStream() {
    final sink = RustStreamSink<FlutterVersionState>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_StreamSink_flutter_version_state_Sse(sink, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 34, port: port_);
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: null,
          ),
          constMeta: kCrateApiFullSetVersionStateStreamConstMeta,
          argValues: [sink],
          apiImpl: this,
        ),
      ),
    );
    return sink.stream;
  }

  TaskConstMeta get kCrateApiFullSetVersionStateStreamConstMeta => const TaskConstMeta(
        debugName: 'set_version_state_stream',
        argNames: ['sink'],
      );

  @override
  Future<StartDisclosureResult> crateApiFullStartDisclosure({required String uri, required bool isQrCode}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(uri, serializer);
          sse_encode_bool(isQrCode, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 35, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_start_disclosure_result,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullStartDisclosureConstMeta,
        argValues: [uri, isQrCode],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullStartDisclosureConstMeta => const TaskConstMeta(
        debugName: 'start_disclosure',
        argNames: ['uri', 'isQrCode'],
      );

  @override
  Future<WalletInstructionResult> crateApiFullUnlockWallet({required String pin}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(pin, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 36, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_wallet_instruction_result,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullUnlockWalletConstMeta,
        argValues: [pin],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullUnlockWalletConstMeta => const TaskConstMeta(
        debugName: 'unlock_wallet',
        argNames: ['pin'],
      );

  @override
  Future<void> crateApiFullUnlockWalletWithBiometrics() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 37, port: port_);
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiFullUnlockWalletWithBiometricsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFullUnlockWalletWithBiometricsConstMeta => const TaskConstMeta(
        debugName: 'unlock_wallet_with_biometrics',
        argNames: [],
      );

  @protected
  AnyhowException dco_decode_AnyhowException(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  RustStreamSink<bool> dco_decode_StreamSink_bool_Sse(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<FlutterConfiguration> dco_decode_StreamSink_flutter_configuration_Sse(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<FlutterVersionState> dco_decode_StreamSink_flutter_version_state_Sse(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<List<Card>> dco_decode_StreamSink_list_card_Sse(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<List<WalletEvent>> dco_decode_StreamSink_list_wallet_event_Sse(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AcceptDisclosureResult dco_decode_accept_disclosure_result(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return AcceptDisclosureResult_Ok(
          returnUrl: dco_decode_opt_String(raw[1]),
        );
      case 1:
        return AcceptDisclosureResult_InstructionError(
          error: dco_decode_box_autoadd_wallet_instruction_error(raw[1]),
        );
      default:
        throw Exception('unreachable');
    }
  }

  @protected
  bool dco_decode_bool(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  Card dco_decode_box_autoadd_card(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_card(raw);
  }

  @protected
  Image dco_decode_box_autoadd_image(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_image(raw);
  }

  @protected
  Organization dco_decode_box_autoadd_organization(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_organization(raw);
  }

  @protected
  RequestPolicy dco_decode_box_autoadd_request_policy(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_request_policy(raw);
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  WalletInstructionError dco_decode_box_autoadd_wallet_instruction_error(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_wallet_instruction_error(raw);
  }

  @protected
  Card dco_decode_card(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return Card(
      issuer: dco_decode_organization(arr[0]),
      persistence: dco_decode_card_persistence(arr[1]),
      docType: dco_decode_String(arr[2]),
      attributes: dco_decode_list_card_attribute(arr[3]),
    );
  }

  @protected
  CardAttribute dco_decode_card_attribute(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return CardAttribute(
      key: dco_decode_String(arr[0]),
      labels: dco_decode_list_localized_string(arr[1]),
      value: dco_decode_card_value(arr[2]),
    );
  }

  @protected
  CardPersistence dco_decode_card_persistence(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return const CardPersistence_InMemory();
      case 1:
        return CardPersistence_Stored(
          id: dco_decode_String(raw[1]),
        );
      default:
        throw Exception('unreachable');
    }
  }

  @protected
  CardValue dco_decode_card_value(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return CardValue_String(
          value: dco_decode_String(raw[1]),
        );
      case 1:
        return CardValue_Boolean(
          value: dco_decode_bool(raw[1]),
        );
      case 2:
        return CardValue_Date(
          value: dco_decode_String(raw[1]),
        );
      case 3:
        return CardValue_Gender(
          value: dco_decode_gender_card_value(raw[1]),
        );
      default:
        throw Exception('unreachable');
    }
  }

  @protected
  DisclosureCard dco_decode_disclosure_card(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return DisclosureCard(
      issuer: dco_decode_organization(arr[0]),
      docType: dco_decode_String(arr[1]),
      attributes: dco_decode_list_card_attribute(arr[2]),
    );
  }

  @protected
  DisclosureSessionType dco_decode_disclosure_session_type(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DisclosureSessionType.values[raw as int];
  }

  @protected
  DisclosureStatus dco_decode_disclosure_status(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DisclosureStatus.values[raw as int];
  }

  @protected
  DisclosureType dco_decode_disclosure_type(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DisclosureType.values[raw as int];
  }

  @protected
  FlutterConfiguration dco_decode_flutter_configuration(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return FlutterConfiguration(
      inactiveLockTimeout: dco_decode_u_16(arr[0]),
      backgroundLockTimeout: dco_decode_u_16(arr[1]),
      version: dco_decode_u_64(arr[2]),
    );
  }

  @protected
  FlutterVersionState dco_decode_flutter_version_state(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return const FlutterVersionState_Ok();
      case 1:
        return const FlutterVersionState_Notify();
      case 2:
        return const FlutterVersionState_Recommend();
      case 3:
        return FlutterVersionState_Warn(
          expiresInSeconds: dco_decode_u_64(raw[1]),
        );
      case 4:
        return const FlutterVersionState_Block();
      default:
        throw Exception('unreachable');
    }
  }

  @protected
  GenderCardValue dco_decode_gender_card_value(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return GenderCardValue.values[raw as int];
  }

  @protected
  int dco_decode_i_32(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  IdentifyUriResult dco_decode_identify_uri_result(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return IdentifyUriResult.values[raw as int];
  }

  @protected
  Image dco_decode_image(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Image_Svg(
          xml: dco_decode_String(raw[1]),
        );
      case 1:
        return Image_Png(
          base64: dco_decode_String(raw[1]),
        );
      case 2:
        return Image_Jpg(
          base64: dco_decode_String(raw[1]),
        );
      case 3:
        return Image_Asset(
          path: dco_decode_String(raw[1]),
        );
      default:
        throw Exception('unreachable');
    }
  }

  @protected
  List<Card> dco_decode_list_card(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_card).toList();
  }

  @protected
  List<CardAttribute> dco_decode_list_card_attribute(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_card_attribute).toList();
  }

  @protected
  List<DisclosureCard> dco_decode_list_disclosure_card(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_disclosure_card).toList();
  }

  @protected
  List<LocalizedString> dco_decode_list_localized_string(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_localized_string).toList();
  }

  @protected
  List<MissingAttribute> dco_decode_list_missing_attribute(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_missing_attribute).toList();
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<WalletEvent> dco_decode_list_wallet_event(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_wallet_event).toList();
  }

  @protected
  LocalizedString dco_decode_localized_string(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return LocalizedString(
      language: dco_decode_String(arr[0]),
      value: dco_decode_String(arr[1]),
    );
  }

  @protected
  MissingAttribute dco_decode_missing_attribute(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return MissingAttribute(
      labels: dco_decode_list_localized_string(arr[0]),
    );
  }

  @protected
  String? dco_decode_opt_String(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  Image? dco_decode_opt_box_autoadd_image(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_image(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  List<DisclosureCard>? dco_decode_opt_list_disclosure_card(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_disclosure_card(raw);
  }

  @protected
  List<LocalizedString>? dco_decode_opt_list_localized_string(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_localized_string(raw);
  }

  @protected
  Organization dco_decode_organization(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11) throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return Organization(
      legalName: dco_decode_list_localized_string(arr[0]),
      displayName: dco_decode_list_localized_string(arr[1]),
      description: dco_decode_list_localized_string(arr[2]),
      image: dco_decode_opt_box_autoadd_image(arr[3]),
      webUrl: dco_decode_opt_String(arr[4]),
      privacyPolicyUrl: dco_decode_opt_String(arr[5]),
      kvk: dco_decode_opt_String(arr[6]),
      city: dco_decode_opt_list_localized_string(arr[7]),
      category: dco_decode_list_localized_string(arr[8]),
      department: dco_decode_opt_list_localized_string(arr[9]),
      countryCode: dco_decode_opt_String(arr[10]),
    );
  }

  @protected
  PinValidationResult dco_decode_pin_validation_result(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PinValidationResult.values[raw as int];
  }

  @protected
  RequestPolicy dco_decode_request_policy(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return RequestPolicy(
      dataStorageDurationInMinutes: dco_decode_opt_box_autoadd_u_64(arr[0]),
      dataSharedWithThirdParties: dco_decode_bool(arr[1]),
      dataDeletionPossible: dco_decode_bool(arr[2]),
      policyUrl: dco_decode_String(arr[3]),
    );
  }

  @protected
  StartDisclosureResult dco_decode_start_disclosure_result(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return StartDisclosureResult_Request(
          relyingParty: dco_decode_box_autoadd_organization(raw[1]),
          policy: dco_decode_box_autoadd_request_policy(raw[2]),
          requestedCards: dco_decode_list_disclosure_card(raw[3]),
          sharedDataWithRelyingPartyBefore: dco_decode_bool(raw[4]),
          sessionType: dco_decode_disclosure_session_type(raw[5]),
          requestPurpose: dco_decode_list_localized_string(raw[6]),
          requestOriginBaseUrl: dco_decode_String(raw[7]),
          requestType: dco_decode_disclosure_type(raw[8]),
        );
      case 1:
        return StartDisclosureResult_RequestAttributesMissing(
          relyingParty: dco_decode_box_autoadd_organization(raw[1]),
          missingAttributes: dco_decode_list_missing_attribute(raw[2]),
          sharedDataWithRelyingPartyBefore: dco_decode_bool(raw[3]),
          sessionType: dco_decode_disclosure_session_type(raw[4]),
          requestPurpose: dco_decode_list_localized_string(raw[5]),
          requestOriginBaseUrl: dco_decode_String(raw[6]),
        );
      default:
        throw Exception('unreachable');
    }
  }

  @protected
  int dco_decode_u_16(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  WalletEvent dco_decode_wallet_event(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return WalletEvent_Disclosure(
          dateTime: dco_decode_String(raw[1]),
          relyingParty: dco_decode_box_autoadd_organization(raw[2]),
          purpose: dco_decode_list_localized_string(raw[3]),
          requestedCards: dco_decode_opt_list_disclosure_card(raw[4]),
          requestPolicy: dco_decode_box_autoadd_request_policy(raw[5]),
          status: dco_decode_disclosure_status(raw[6]),
          type: dco_decode_disclosure_type(raw[7]),
        );
      case 1:
        return WalletEvent_Issuance(
          dateTime: dco_decode_String(raw[1]),
          card: dco_decode_box_autoadd_card(raw[2]),
        );
      default:
        throw Exception('unreachable');
    }
  }

  @protected
  WalletInstructionError dco_decode_wallet_instruction_error(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return WalletInstructionError_IncorrectPin(
          attemptsLeftInRound: dco_decode_u_8(raw[1]),
          isFinalRound: dco_decode_bool(raw[2]),
        );
      case 1:
        return WalletInstructionError_Timeout(
          timeoutMillis: dco_decode_u_64(raw[1]),
        );
      case 2:
        return const WalletInstructionError_Blocked();
      default:
        throw Exception('unreachable');
    }
  }

  @protected
  WalletInstructionResult dco_decode_wallet_instruction_result(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return const WalletInstructionResult_Ok();
      case 1:
        return WalletInstructionResult_InstructionError(
          error: dco_decode_box_autoadd_wallet_instruction_error(raw[1]),
        );
      default:
        throw Exception('unreachable');
    }
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  RustStreamSink<bool> sse_decode_StreamSink_bool_Sse(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<FlutterConfiguration> sse_decode_StreamSink_flutter_configuration_Sse(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<FlutterVersionState> sse_decode_StreamSink_flutter_version_state_Sse(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<List<Card>> sse_decode_StreamSink_list_card_Sse(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<List<WalletEvent>> sse_decode_StreamSink_list_wallet_event_Sse(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AcceptDisclosureResult sse_decode_accept_disclosure_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        final var_returnUrl = sse_decode_opt_String(deserializer);
        return AcceptDisclosureResult_Ok(returnUrl: var_returnUrl);
      case 1:
        final var_error = sse_decode_box_autoadd_wallet_instruction_error(deserializer);
        return AcceptDisclosureResult_InstructionError(error: var_error);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  Card sse_decode_box_autoadd_card(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return sse_decode_card(deserializer);
  }

  @protected
  Image sse_decode_box_autoadd_image(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return sse_decode_image(deserializer);
  }

  @protected
  Organization sse_decode_box_autoadd_organization(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return sse_decode_organization(deserializer);
  }

  @protected
  RequestPolicy sse_decode_box_autoadd_request_policy(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return sse_decode_request_policy(deserializer);
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return sse_decode_u_64(deserializer);
  }

  @protected
  WalletInstructionError sse_decode_box_autoadd_wallet_instruction_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return sse_decode_wallet_instruction_error(deserializer);
  }

  @protected
  Card sse_decode_card(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_issuer = sse_decode_organization(deserializer);
    final var_persistence = sse_decode_card_persistence(deserializer);
    final var_docType = sse_decode_String(deserializer);
    final var_attributes = sse_decode_list_card_attribute(deserializer);
    return Card(issuer: var_issuer, persistence: var_persistence, docType: var_docType, attributes: var_attributes);
  }

  @protected
  CardAttribute sse_decode_card_attribute(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_key = sse_decode_String(deserializer);
    final var_labels = sse_decode_list_localized_string(deserializer);
    final var_value = sse_decode_card_value(deserializer);
    return CardAttribute(key: var_key, labels: var_labels, value: var_value);
  }

  @protected
  CardPersistence sse_decode_card_persistence(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return const CardPersistence_InMemory();
      case 1:
        final var_id = sse_decode_String(deserializer);
        return CardPersistence_Stored(id: var_id);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  CardValue sse_decode_card_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        final var_value = sse_decode_String(deserializer);
        return CardValue_String(value: var_value);
      case 1:
        final var_value = sse_decode_bool(deserializer);
        return CardValue_Boolean(value: var_value);
      case 2:
        final var_value = sse_decode_String(deserializer);
        return CardValue_Date(value: var_value);
      case 3:
        final var_value = sse_decode_gender_card_value(deserializer);
        return CardValue_Gender(value: var_value);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  DisclosureCard sse_decode_disclosure_card(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_issuer = sse_decode_organization(deserializer);
    final var_docType = sse_decode_String(deserializer);
    final var_attributes = sse_decode_list_card_attribute(deserializer);
    return DisclosureCard(issuer: var_issuer, docType: var_docType, attributes: var_attributes);
  }

  @protected
  DisclosureSessionType sse_decode_disclosure_session_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final inner = sse_decode_i_32(deserializer);
    return DisclosureSessionType.values[inner];
  }

  @protected
  DisclosureStatus sse_decode_disclosure_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final inner = sse_decode_i_32(deserializer);
    return DisclosureStatus.values[inner];
  }

  @protected
  DisclosureType sse_decode_disclosure_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final inner = sse_decode_i_32(deserializer);
    return DisclosureType.values[inner];
  }

  @protected
  FlutterConfiguration sse_decode_flutter_configuration(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_inactiveLockTimeout = sse_decode_u_16(deserializer);
    final var_backgroundLockTimeout = sse_decode_u_16(deserializer);
    final var_version = sse_decode_u_64(deserializer);
    return FlutterConfiguration(
        inactiveLockTimeout: var_inactiveLockTimeout,
        backgroundLockTimeout: var_backgroundLockTimeout,
        version: var_version);
  }

  @protected
  FlutterVersionState sse_decode_flutter_version_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return const FlutterVersionState_Ok();
      case 1:
        return const FlutterVersionState_Notify();
      case 2:
        return const FlutterVersionState_Recommend();
      case 3:
        final var_expiresInSeconds = sse_decode_u_64(deserializer);
        return FlutterVersionState_Warn(expiresInSeconds: var_expiresInSeconds);
      case 4:
        return const FlutterVersionState_Block();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  GenderCardValue sse_decode_gender_card_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final inner = sse_decode_i_32(deserializer);
    return GenderCardValue.values[inner];
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  IdentifyUriResult sse_decode_identify_uri_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final inner = sse_decode_i_32(deserializer);
    return IdentifyUriResult.values[inner];
  }

  @protected
  Image sse_decode_image(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        final var_xml = sse_decode_String(deserializer);
        return Image_Svg(xml: var_xml);
      case 1:
        final var_base64 = sse_decode_String(deserializer);
        return Image_Png(base64: var_base64);
      case 2:
        final var_base64 = sse_decode_String(deserializer);
        return Image_Jpg(base64: var_base64);
      case 3:
        final var_path = sse_decode_String(deserializer);
        return Image_Asset(path: var_path);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  List<Card> sse_decode_list_card(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <Card>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_card(deserializer));
    }
    return ans_;
  }

  @protected
  List<CardAttribute> sse_decode_list_card_attribute(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <CardAttribute>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_card_attribute(deserializer));
    }
    return ans_;
  }

  @protected
  List<DisclosureCard> sse_decode_list_disclosure_card(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <DisclosureCard>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_disclosure_card(deserializer));
    }
    return ans_;
  }

  @protected
  List<LocalizedString> sse_decode_list_localized_string(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <LocalizedString>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_localized_string(deserializer));
    }
    return ans_;
  }

  @protected
  List<MissingAttribute> sse_decode_list_missing_attribute(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <MissingAttribute>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_missing_attribute(deserializer));
    }
    return ans_;
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<WalletEvent> sse_decode_list_wallet_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final len_ = sse_decode_i_32(deserializer);
    final ans_ = <WalletEvent>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_wallet_event(deserializer));
    }
    return ans_;
  }

  @protected
  LocalizedString sse_decode_localized_string(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_language = sse_decode_String(deserializer);
    final var_value = sse_decode_String(deserializer);
    return LocalizedString(language: var_language, value: var_value);
  }

  @protected
  MissingAttribute sse_decode_missing_attribute(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_labels = sse_decode_list_localized_string(deserializer);
    return MissingAttribute(labels: var_labels);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return sse_decode_String(deserializer);
    } else {
      return null;
    }
  }

  @protected
  Image? sse_decode_opt_box_autoadd_image(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return sse_decode_box_autoadd_image(deserializer);
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return sse_decode_box_autoadd_u_64(deserializer);
    } else {
      return null;
    }
  }

  @protected
  List<DisclosureCard>? sse_decode_opt_list_disclosure_card(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return sse_decode_list_disclosure_card(deserializer);
    } else {
      return null;
    }
  }

  @protected
  List<LocalizedString>? sse_decode_opt_list_localized_string(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return sse_decode_list_localized_string(deserializer);
    } else {
      return null;
    }
  }

  @protected
  Organization sse_decode_organization(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_legalName = sse_decode_list_localized_string(deserializer);
    final var_displayName = sse_decode_list_localized_string(deserializer);
    final var_description = sse_decode_list_localized_string(deserializer);
    final var_image = sse_decode_opt_box_autoadd_image(deserializer);
    final var_webUrl = sse_decode_opt_String(deserializer);
    final var_privacyPolicyUrl = sse_decode_opt_String(deserializer);
    final var_kvk = sse_decode_opt_String(deserializer);
    final var_city = sse_decode_opt_list_localized_string(deserializer);
    final var_category = sse_decode_list_localized_string(deserializer);
    final var_department = sse_decode_opt_list_localized_string(deserializer);
    final var_countryCode = sse_decode_opt_String(deserializer);
    return Organization(
        legalName: var_legalName,
        displayName: var_displayName,
        description: var_description,
        image: var_image,
        webUrl: var_webUrl,
        privacyPolicyUrl: var_privacyPolicyUrl,
        kvk: var_kvk,
        city: var_city,
        category: var_category,
        department: var_department,
        countryCode: var_countryCode);
  }

  @protected
  PinValidationResult sse_decode_pin_validation_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final inner = sse_decode_i_32(deserializer);
    return PinValidationResult.values[inner];
  }

  @protected
  RequestPolicy sse_decode_request_policy(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final var_dataStorageDurationInMinutes = sse_decode_opt_box_autoadd_u_64(deserializer);
    final var_dataSharedWithThirdParties = sse_decode_bool(deserializer);
    final var_dataDeletionPossible = sse_decode_bool(deserializer);
    final var_policyUrl = sse_decode_String(deserializer);
    return RequestPolicy(
        dataStorageDurationInMinutes: var_dataStorageDurationInMinutes,
        dataSharedWithThirdParties: var_dataSharedWithThirdParties,
        dataDeletionPossible: var_dataDeletionPossible,
        policyUrl: var_policyUrl);
  }

  @protected
  StartDisclosureResult sse_decode_start_disclosure_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        final var_relyingParty = sse_decode_box_autoadd_organization(deserializer);
        final var_policy = sse_decode_box_autoadd_request_policy(deserializer);
        final var_requestedCards = sse_decode_list_disclosure_card(deserializer);
        final var_sharedDataWithRelyingPartyBefore = sse_decode_bool(deserializer);
        final var_sessionType = sse_decode_disclosure_session_type(deserializer);
        final var_requestPurpose = sse_decode_list_localized_string(deserializer);
        final var_requestOriginBaseUrl = sse_decode_String(deserializer);
        final var_requestType = sse_decode_disclosure_type(deserializer);
        return StartDisclosureResult_Request(
            relyingParty: var_relyingParty,
            policy: var_policy,
            requestedCards: var_requestedCards,
            sharedDataWithRelyingPartyBefore: var_sharedDataWithRelyingPartyBefore,
            sessionType: var_sessionType,
            requestPurpose: var_requestPurpose,
            requestOriginBaseUrl: var_requestOriginBaseUrl,
            requestType: var_requestType);
      case 1:
        final var_relyingParty = sse_decode_box_autoadd_organization(deserializer);
        final var_missingAttributes = sse_decode_list_missing_attribute(deserializer);
        final var_sharedDataWithRelyingPartyBefore = sse_decode_bool(deserializer);
        final var_sessionType = sse_decode_disclosure_session_type(deserializer);
        final var_requestPurpose = sse_decode_list_localized_string(deserializer);
        final var_requestOriginBaseUrl = sse_decode_String(deserializer);
        return StartDisclosureResult_RequestAttributesMissing(
            relyingParty: var_relyingParty,
            missingAttributes: var_missingAttributes,
            sharedDataWithRelyingPartyBefore: var_sharedDataWithRelyingPartyBefore,
            sessionType: var_sessionType,
            requestPurpose: var_requestPurpose,
            requestOriginBaseUrl: var_requestOriginBaseUrl);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  WalletEvent sse_decode_wallet_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        final var_dateTime = sse_decode_String(deserializer);
        final var_relyingParty = sse_decode_box_autoadd_organization(deserializer);
        final var_purpose = sse_decode_list_localized_string(deserializer);
        final var_requestedCards = sse_decode_opt_list_disclosure_card(deserializer);
        final var_requestPolicy = sse_decode_box_autoadd_request_policy(deserializer);
        final var_status = sse_decode_disclosure_status(deserializer);
        final var_type = sse_decode_disclosure_type(deserializer);
        return WalletEvent_Disclosure(
            dateTime: var_dateTime,
            relyingParty: var_relyingParty,
            purpose: var_purpose,
            requestedCards: var_requestedCards,
            requestPolicy: var_requestPolicy,
            status: var_status,
            type: var_type);
      case 1:
        final var_dateTime = sse_decode_String(deserializer);
        final var_card = sse_decode_box_autoadd_card(deserializer);
        return WalletEvent_Issuance(dateTime: var_dateTime, card: var_card);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  WalletInstructionError sse_decode_wallet_instruction_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        final var_attemptsLeftInRound = sse_decode_u_8(deserializer);
        final var_isFinalRound = sse_decode_bool(deserializer);
        return WalletInstructionError_IncorrectPin(
            attemptsLeftInRound: var_attemptsLeftInRound, isFinalRound: var_isFinalRound);
      case 1:
        final var_timeoutMillis = sse_decode_u_64(deserializer);
        return WalletInstructionError_Timeout(timeoutMillis: var_timeoutMillis);
      case 2:
        return const WalletInstructionError_Blocked();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  WalletInstructionResult sse_decode_wallet_instruction_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return const WalletInstructionResult_Ok();
      case 1:
        final var_error = sse_decode_box_autoadd_wallet_instruction_error(deserializer);
        return WalletInstructionResult_InstructionError(error: var_error);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_AnyhowException(AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_StreamSink_bool_Sse(RustStreamSink<bool> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_StreamSink_flutter_configuration_Sse(
      RustStreamSink<FlutterConfiguration> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: SseCodec(
          decodeSuccessData: sse_decode_flutter_configuration,
          decodeErrorData: sse_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_StreamSink_flutter_version_state_Sse(
      RustStreamSink<FlutterVersionState> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: SseCodec(
          decodeSuccessData: sse_decode_flutter_version_state,
          decodeErrorData: sse_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_StreamSink_list_card_Sse(RustStreamSink<List<Card>> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_card,
          decodeErrorData: sse_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_StreamSink_list_wallet_event_Sse(RustStreamSink<List<WalletEvent>> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_wallet_event,
          decodeErrorData: sse_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_accept_disclosure_result(AcceptDisclosureResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case AcceptDisclosureResult_Ok(returnUrl: final returnUrl):
        sse_encode_i_32(0, serializer);
        sse_encode_opt_String(returnUrl, serializer);
      case AcceptDisclosureResult_InstructionError(error: final error):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_wallet_instruction_error(error, serializer);
    }
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_card(Card self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_card(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_image(Image self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_image(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_organization(Organization self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_organization(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_request_policy(RequestPolicy self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_request_policy(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_wallet_instruction_error(WalletInstructionError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_wallet_instruction_error(self, serializer);
  }

  @protected
  void sse_encode_card(Card self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_organization(self.issuer, serializer);
    sse_encode_card_persistence(self.persistence, serializer);
    sse_encode_String(self.docType, serializer);
    sse_encode_list_card_attribute(self.attributes, serializer);
  }

  @protected
  void sse_encode_card_attribute(CardAttribute self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.key, serializer);
    sse_encode_list_localized_string(self.labels, serializer);
    sse_encode_card_value(self.value, serializer);
  }

  @protected
  void sse_encode_card_persistence(CardPersistence self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case CardPersistence_InMemory():
        sse_encode_i_32(0, serializer);
      case CardPersistence_Stored(id: final id):
        sse_encode_i_32(1, serializer);
        sse_encode_String(id, serializer);
    }
  }

  @protected
  void sse_encode_card_value(CardValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case CardValue_String(value: final value):
        sse_encode_i_32(0, serializer);
        sse_encode_String(value, serializer);
      case CardValue_Boolean(value: final value):
        sse_encode_i_32(1, serializer);
        sse_encode_bool(value, serializer);
      case CardValue_Date(value: final value):
        sse_encode_i_32(2, serializer);
        sse_encode_String(value, serializer);
      case CardValue_Gender(value: final value):
        sse_encode_i_32(3, serializer);
        sse_encode_gender_card_value(value, serializer);
    }
  }

  @protected
  void sse_encode_disclosure_card(DisclosureCard self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_organization(self.issuer, serializer);
    sse_encode_String(self.docType, serializer);
    sse_encode_list_card_attribute(self.attributes, serializer);
  }

  @protected
  void sse_encode_disclosure_session_type(DisclosureSessionType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_disclosure_status(DisclosureStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_disclosure_type(DisclosureType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_flutter_configuration(FlutterConfiguration self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_16(self.inactiveLockTimeout, serializer);
    sse_encode_u_16(self.backgroundLockTimeout, serializer);
    sse_encode_u_64(self.version, serializer);
  }

  @protected
  void sse_encode_flutter_version_state(FlutterVersionState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case FlutterVersionState_Ok():
        sse_encode_i_32(0, serializer);
      case FlutterVersionState_Notify():
        sse_encode_i_32(1, serializer);
      case FlutterVersionState_Recommend():
        sse_encode_i_32(2, serializer);
      case FlutterVersionState_Warn(expiresInSeconds: final expiresInSeconds):
        sse_encode_i_32(3, serializer);
        sse_encode_u_64(expiresInSeconds, serializer);
      case FlutterVersionState_Block():
        sse_encode_i_32(4, serializer);
    }
  }

  @protected
  void sse_encode_gender_card_value(GenderCardValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_identify_uri_result(IdentifyUriResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_image(Image self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Image_Svg(xml: final xml):
        sse_encode_i_32(0, serializer);
        sse_encode_String(xml, serializer);
      case Image_Png(base64: final base64):
        sse_encode_i_32(1, serializer);
        sse_encode_String(base64, serializer);
      case Image_Jpg(base64: final base64):
        sse_encode_i_32(2, serializer);
        sse_encode_String(base64, serializer);
      case Image_Asset(path: final path):
        sse_encode_i_32(3, serializer);
        sse_encode_String(path, serializer);
    }
  }

  @protected
  void sse_encode_list_card(List<Card> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_card(item, serializer);
    }
  }

  @protected
  void sse_encode_list_card_attribute(List<CardAttribute> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_card_attribute(item, serializer);
    }
  }

  @protected
  void sse_encode_list_disclosure_card(List<DisclosureCard> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_disclosure_card(item, serializer);
    }
  }

  @protected
  void sse_encode_list_localized_string(List<LocalizedString> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_localized_string(item, serializer);
    }
  }

  @protected
  void sse_encode_list_missing_attribute(List<MissingAttribute> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_missing_attribute(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_strict(Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_wallet_event(List<WalletEvent> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_wallet_event(item, serializer);
    }
  }

  @protected
  void sse_encode_localized_string(LocalizedString self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.language, serializer);
    sse_encode_String(self.value, serializer);
  }

  @protected
  void sse_encode_missing_attribute(MissingAttribute self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_localized_string(self.labels, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_image(Image? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_image(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_disclosure_card(List<DisclosureCard>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_disclosure_card(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_localized_string(List<LocalizedString>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_localized_string(self, serializer);
    }
  }

  @protected
  void sse_encode_organization(Organization self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_localized_string(self.legalName, serializer);
    sse_encode_list_localized_string(self.displayName, serializer);
    sse_encode_list_localized_string(self.description, serializer);
    sse_encode_opt_box_autoadd_image(self.image, serializer);
    sse_encode_opt_String(self.webUrl, serializer);
    sse_encode_opt_String(self.privacyPolicyUrl, serializer);
    sse_encode_opt_String(self.kvk, serializer);
    sse_encode_opt_list_localized_string(self.city, serializer);
    sse_encode_list_localized_string(self.category, serializer);
    sse_encode_opt_list_localized_string(self.department, serializer);
    sse_encode_opt_String(self.countryCode, serializer);
  }

  @protected
  void sse_encode_pin_validation_result(PinValidationResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_request_policy(RequestPolicy self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_u_64(self.dataStorageDurationInMinutes, serializer);
    sse_encode_bool(self.dataSharedWithThirdParties, serializer);
    sse_encode_bool(self.dataDeletionPossible, serializer);
    sse_encode_String(self.policyUrl, serializer);
  }

  @protected
  void sse_encode_start_disclosure_result(StartDisclosureResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case StartDisclosureResult_Request(
          relyingParty: final relyingParty,
          policy: final policy,
          requestedCards: final requestedCards,
          sharedDataWithRelyingPartyBefore: final sharedDataWithRelyingPartyBefore,
          sessionType: final sessionType,
          requestPurpose: final requestPurpose,
          requestOriginBaseUrl: final requestOriginBaseUrl,
          requestType: final requestType
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_organization(relyingParty, serializer);
        sse_encode_box_autoadd_request_policy(policy, serializer);
        sse_encode_list_disclosure_card(requestedCards, serializer);
        sse_encode_bool(sharedDataWithRelyingPartyBefore, serializer);
        sse_encode_disclosure_session_type(sessionType, serializer);
        sse_encode_list_localized_string(requestPurpose, serializer);
        sse_encode_String(requestOriginBaseUrl, serializer);
        sse_encode_disclosure_type(requestType, serializer);
      case StartDisclosureResult_RequestAttributesMissing(
          relyingParty: final relyingParty,
          missingAttributes: final missingAttributes,
          sharedDataWithRelyingPartyBefore: final sharedDataWithRelyingPartyBefore,
          sessionType: final sessionType,
          requestPurpose: final requestPurpose,
          requestOriginBaseUrl: final requestOriginBaseUrl
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_organization(relyingParty, serializer);
        sse_encode_list_missing_attribute(missingAttributes, serializer);
        sse_encode_bool(sharedDataWithRelyingPartyBefore, serializer);
        sse_encode_disclosure_session_type(sessionType, serializer);
        sse_encode_list_localized_string(requestPurpose, serializer);
        sse_encode_String(requestOriginBaseUrl, serializer);
    }
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_wallet_event(WalletEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case WalletEvent_Disclosure(
          dateTime: final dateTime,
          relyingParty: final relyingParty,
          purpose: final purpose,
          requestedCards: final requestedCards,
          requestPolicy: final requestPolicy,
          status: final status,
          type: final type
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_String(dateTime, serializer);
        sse_encode_box_autoadd_organization(relyingParty, serializer);
        sse_encode_list_localized_string(purpose, serializer);
        sse_encode_opt_list_disclosure_card(requestedCards, serializer);
        sse_encode_box_autoadd_request_policy(requestPolicy, serializer);
        sse_encode_disclosure_status(status, serializer);
        sse_encode_disclosure_type(type, serializer);
      case WalletEvent_Issuance(dateTime: final dateTime, card: final card):
        sse_encode_i_32(1, serializer);
        sse_encode_String(dateTime, serializer);
        sse_encode_box_autoadd_card(card, serializer);
    }
  }

  @protected
  void sse_encode_wallet_instruction_error(WalletInstructionError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case WalletInstructionError_IncorrectPin(
          attemptsLeftInRound: final attemptsLeftInRound,
          isFinalRound: final isFinalRound
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_u_8(attemptsLeftInRound, serializer);
        sse_encode_bool(isFinalRound, serializer);
      case WalletInstructionError_Timeout(timeoutMillis: final timeoutMillis):
        sse_encode_i_32(1, serializer);
        sse_encode_u_64(timeoutMillis, serializer);
      case WalletInstructionError_Blocked():
        sse_encode_i_32(2, serializer);
    }
  }

  @protected
  void sse_encode_wallet_instruction_result(WalletInstructionResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case WalletInstructionResult_Ok():
        sse_encode_i_32(0, serializer);
      case WalletInstructionResult_InstructionError(error: final error):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_wallet_instruction_error(error, serializer);
    }
  }
}
