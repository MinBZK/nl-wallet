// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.7.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/full.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart' if (dart.library.js_interop) 'frb_generated.web.dart';
import 'models/card.dart';
import 'models/config.dart';
import 'models/disclosure.dart';
import 'models/instruction.dart';
import 'models/pin.dart';
import 'models/uri.dart';
import 'models/version_state.dart';
import 'models/wallet_event.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class WalletCore extends BaseEntrypoint<WalletCoreApi, WalletCoreApiImpl, WalletCoreWire> {
  @internal
  static final instance = WalletCore._();

  WalletCore._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    WalletCoreApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required WalletCoreApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<WalletCoreApiImpl, WalletCoreWire> get apiImplConstructor => WalletCoreApiImpl.new;

  @override
  WireConstructor<WalletCoreWire> get wireConstructor => WalletCoreWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiFullInit();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig => kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.7.1';

  @override
  int get rustContentHash => -580739876;

  static const kDefaultExternalLibraryLoaderConfig = ExternalLibraryLoaderConfig(
    stem: 'wallet_core',
    ioDirectory: '../../../wallet_core/flutter_api/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class WalletCoreApi extends BaseApi {
  Future<AcceptDisclosureResult> crateApiFullAcceptDisclosure({required String pin});

  Future<WalletInstructionResult> crateApiFullAcceptPidIssuance({required String pin});

  Future<String?> crateApiFullCancelDisclosure();

  Future<void> crateApiFullCancelPidIssuance();

  Future<WalletInstructionResult> crateApiFullChangePin({required String oldPin, required String newPin});

  Future<WalletInstructionResult> crateApiFullCheckPin({required String pin});

  Future<void> crateApiFullClearCardsStream();

  Future<void> crateApiFullClearConfigurationStream();

  Future<void> crateApiFullClearLockStream();

  Future<void> crateApiFullClearRecentHistoryStream();

  Future<void> crateApiFullClearVersionStateStream();

  Future<WalletInstructionResult> crateApiFullContinueChangePin({required String pin});

  Future<List<Card>> crateApiFullContinuePidIssuance({required String uri});

  Future<String> crateApiFullCreatePidIssuanceRedirectUri();

  Future<List<WalletEvent>> crateApiFullGetHistory();

  Future<List<WalletEvent>> crateApiFullGetHistoryForCard({required String docType});

  Future<String> crateApiFullGetVersionString();

  Future<bool> crateApiFullHasActiveDisclosureSession();

  Future<bool> crateApiFullHasActivePidIssuanceSession();

  Future<bool> crateApiFullHasRegistration();

  Future<IdentifyUriResult> crateApiFullIdentifyUri({required String uri});

  Future<void> crateApiFullInit();

  Future<bool> crateApiFullIsBiometricUnlockEnabled();

  Future<bool> crateApiFullIsInitialized();

  Future<PinValidationResult> crateApiFullIsValidPin({required String pin});

  Future<void> crateApiFullLockWallet();

  Future<void> crateApiFullRegister({required String pin});

  Future<void> crateApiFullResetWallet();

  Future<void> crateApiFullSetBiometricUnlock({required bool enable});

  Stream<List<Card>> crateApiFullSetCardsStream();

  Stream<FlutterConfiguration> crateApiFullSetConfigurationStream();

  Stream<bool> crateApiFullSetLockStream();

  Stream<List<WalletEvent>> crateApiFullSetRecentHistoryStream();

  Stream<FlutterVersionState> crateApiFullSetVersionStateStream();

  Future<StartDisclosureResult> crateApiFullStartDisclosure({required String uri, required bool isQrCode});

  Future<WalletInstructionResult> crateApiFullUnlockWallet({required String pin});

  Future<void> crateApiFullUnlockWalletWithBiometrics();
}

class WalletCoreApiImpl extends WalletCoreApiImplPlatform implements WalletCoreApi {
  WalletCoreApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<AcceptDisclosureResult> crateApiFullAcceptDisclosure({required String pin}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(pin);
        return wire.wire__crate__api__full__accept_disclosure(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_accept_disclosure_result,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullAcceptDisclosureConstMeta,
      argValues: [pin],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullAcceptDisclosureConstMeta => const TaskConstMeta(
        debugName: "accept_disclosure",
        argNames: ["pin"],
      );

  @override
  Future<WalletInstructionResult> crateApiFullAcceptPidIssuance({required String pin}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(pin);
        return wire.wire__crate__api__full__accept_pid_issuance(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_wallet_instruction_result,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullAcceptPidIssuanceConstMeta,
      argValues: [pin],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullAcceptPidIssuanceConstMeta => const TaskConstMeta(
        debugName: "accept_pid_issuance",
        argNames: ["pin"],
      );

  @override
  Future<String?> crateApiFullCancelDisclosure() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__cancel_disclosure(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_String,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullCancelDisclosureConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullCancelDisclosureConstMeta => const TaskConstMeta(
        debugName: "cancel_disclosure",
        argNames: [],
      );

  @override
  Future<void> crateApiFullCancelPidIssuance() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__cancel_pid_issuance(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullCancelPidIssuanceConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullCancelPidIssuanceConstMeta => const TaskConstMeta(
        debugName: "cancel_pid_issuance",
        argNames: [],
      );

  @override
  Future<WalletInstructionResult> crateApiFullChangePin({required String oldPin, required String newPin}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(oldPin);
        var arg1 = cst_encode_String(newPin);
        return wire.wire__crate__api__full__change_pin(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_wallet_instruction_result,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullChangePinConstMeta,
      argValues: [oldPin, newPin],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullChangePinConstMeta => const TaskConstMeta(
        debugName: "change_pin",
        argNames: ["oldPin", "newPin"],
      );

  @override
  Future<WalletInstructionResult> crateApiFullCheckPin({required String pin}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(pin);
        return wire.wire__crate__api__full__check_pin(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_wallet_instruction_result,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullCheckPinConstMeta,
      argValues: [pin],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullCheckPinConstMeta => const TaskConstMeta(
        debugName: "check_pin",
        argNames: ["pin"],
      );

  @override
  Future<void> crateApiFullClearCardsStream() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__clear_cards_stream(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullClearCardsStreamConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullClearCardsStreamConstMeta => const TaskConstMeta(
        debugName: "clear_cards_stream",
        argNames: [],
      );

  @override
  Future<void> crateApiFullClearConfigurationStream() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__clear_configuration_stream(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullClearConfigurationStreamConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullClearConfigurationStreamConstMeta => const TaskConstMeta(
        debugName: "clear_configuration_stream",
        argNames: [],
      );

  @override
  Future<void> crateApiFullClearLockStream() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__clear_lock_stream(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullClearLockStreamConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullClearLockStreamConstMeta => const TaskConstMeta(
        debugName: "clear_lock_stream",
        argNames: [],
      );

  @override
  Future<void> crateApiFullClearRecentHistoryStream() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__clear_recent_history_stream(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullClearRecentHistoryStreamConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullClearRecentHistoryStreamConstMeta => const TaskConstMeta(
        debugName: "clear_recent_history_stream",
        argNames: [],
      );

  @override
  Future<void> crateApiFullClearVersionStateStream() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__clear_version_state_stream(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullClearVersionStateStreamConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullClearVersionStateStreamConstMeta => const TaskConstMeta(
        debugName: "clear_version_state_stream",
        argNames: [],
      );

  @override
  Future<WalletInstructionResult> crateApiFullContinueChangePin({required String pin}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(pin);
        return wire.wire__crate__api__full__continue_change_pin(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_wallet_instruction_result,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullContinueChangePinConstMeta,
      argValues: [pin],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullContinueChangePinConstMeta => const TaskConstMeta(
        debugName: "continue_change_pin",
        argNames: ["pin"],
      );

  @override
  Future<List<Card>> crateApiFullContinuePidIssuance({required String uri}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(uri);
        return wire.wire__crate__api__full__continue_pid_issuance(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_card,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullContinuePidIssuanceConstMeta,
      argValues: [uri],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullContinuePidIssuanceConstMeta => const TaskConstMeta(
        debugName: "continue_pid_issuance",
        argNames: ["uri"],
      );

  @override
  Future<String> crateApiFullCreatePidIssuanceRedirectUri() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__create_pid_issuance_redirect_uri(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullCreatePidIssuanceRedirectUriConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullCreatePidIssuanceRedirectUriConstMeta => const TaskConstMeta(
        debugName: "create_pid_issuance_redirect_uri",
        argNames: [],
      );

  @override
  Future<List<WalletEvent>> crateApiFullGetHistory() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__get_history(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_wallet_event,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullGetHistoryConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullGetHistoryConstMeta => const TaskConstMeta(
        debugName: "get_history",
        argNames: [],
      );

  @override
  Future<List<WalletEvent>> crateApiFullGetHistoryForCard({required String docType}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(docType);
        return wire.wire__crate__api__full__get_history_for_card(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_wallet_event,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullGetHistoryForCardConstMeta,
      argValues: [docType],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullGetHistoryForCardConstMeta => const TaskConstMeta(
        debugName: "get_history_for_card",
        argNames: ["docType"],
      );

  @override
  Future<String> crateApiFullGetVersionString() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__get_version_string(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullGetVersionStringConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullGetVersionStringConstMeta => const TaskConstMeta(
        debugName: "get_version_string",
        argNames: [],
      );

  @override
  Future<bool> crateApiFullHasActiveDisclosureSession() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__has_active_disclosure_session(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullHasActiveDisclosureSessionConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullHasActiveDisclosureSessionConstMeta => const TaskConstMeta(
        debugName: "has_active_disclosure_session",
        argNames: [],
      );

  @override
  Future<bool> crateApiFullHasActivePidIssuanceSession() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__has_active_pid_issuance_session(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullHasActivePidIssuanceSessionConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullHasActivePidIssuanceSessionConstMeta => const TaskConstMeta(
        debugName: "has_active_pid_issuance_session",
        argNames: [],
      );

  @override
  Future<bool> crateApiFullHasRegistration() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__has_registration(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullHasRegistrationConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullHasRegistrationConstMeta => const TaskConstMeta(
        debugName: "has_registration",
        argNames: [],
      );

  @override
  Future<IdentifyUriResult> crateApiFullIdentifyUri({required String uri}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(uri);
        return wire.wire__crate__api__full__identify_uri(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_identify_uri_result,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullIdentifyUriConstMeta,
      argValues: [uri],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullIdentifyUriConstMeta => const TaskConstMeta(
        debugName: "identify_uri",
        argNames: ["uri"],
      );

  @override
  Future<void> crateApiFullInit() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__init(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullInitConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullInitConstMeta => const TaskConstMeta(
        debugName: "init",
        argNames: [],
      );

  @override
  Future<bool> crateApiFullIsBiometricUnlockEnabled() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__is_biometric_unlock_enabled(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullIsBiometricUnlockEnabledConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullIsBiometricUnlockEnabledConstMeta => const TaskConstMeta(
        debugName: "is_biometric_unlock_enabled",
        argNames: [],
      );

  @override
  Future<bool> crateApiFullIsInitialized() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__is_initialized(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullIsInitializedConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullIsInitializedConstMeta => const TaskConstMeta(
        debugName: "is_initialized",
        argNames: [],
      );

  @override
  Future<PinValidationResult> crateApiFullIsValidPin({required String pin}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(pin);
        return wire.wire__crate__api__full__is_valid_pin(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_pin_validation_result,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullIsValidPinConstMeta,
      argValues: [pin],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullIsValidPinConstMeta => const TaskConstMeta(
        debugName: "is_valid_pin",
        argNames: ["pin"],
      );

  @override
  Future<void> crateApiFullLockWallet() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__lock_wallet(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullLockWalletConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullLockWalletConstMeta => const TaskConstMeta(
        debugName: "lock_wallet",
        argNames: [],
      );

  @override
  Future<void> crateApiFullRegister({required String pin}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(pin);
        return wire.wire__crate__api__full__register(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullRegisterConstMeta,
      argValues: [pin],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullRegisterConstMeta => const TaskConstMeta(
        debugName: "register",
        argNames: ["pin"],
      );

  @override
  Future<void> crateApiFullResetWallet() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__reset_wallet(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullResetWalletConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullResetWalletConstMeta => const TaskConstMeta(
        debugName: "reset_wallet",
        argNames: [],
      );

  @override
  Future<void> crateApiFullSetBiometricUnlock({required bool enable}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_bool(enable);
        return wire.wire__crate__api__full__set_biometric_unlock(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullSetBiometricUnlockConstMeta,
      argValues: [enable],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullSetBiometricUnlockConstMeta => const TaskConstMeta(
        debugName: "set_biometric_unlock",
        argNames: ["enable"],
      );

  @override
  Stream<List<Card>> crateApiFullSetCardsStream() {
    final sink = RustStreamSink<List<Card>>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_StreamSink_list_card_Dco(sink);
        return wire.wire__crate__api__full__set_cards_stream(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullSetCardsStreamConstMeta,
      argValues: [sink],
      apiImpl: this,
    )));
    return sink.stream;
  }

  TaskConstMeta get kCrateApiFullSetCardsStreamConstMeta => const TaskConstMeta(
        debugName: "set_cards_stream",
        argNames: ["sink"],
      );

  @override
  Stream<FlutterConfiguration> crateApiFullSetConfigurationStream() {
    final sink = RustStreamSink<FlutterConfiguration>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_StreamSink_flutter_configuration_Dco(sink);
        return wire.wire__crate__api__full__set_configuration_stream(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullSetConfigurationStreamConstMeta,
      argValues: [sink],
      apiImpl: this,
    )));
    return sink.stream;
  }

  TaskConstMeta get kCrateApiFullSetConfigurationStreamConstMeta => const TaskConstMeta(
        debugName: "set_configuration_stream",
        argNames: ["sink"],
      );

  @override
  Stream<bool> crateApiFullSetLockStream() {
    final sink = RustStreamSink<bool>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_StreamSink_bool_Dco(sink);
        return wire.wire__crate__api__full__set_lock_stream(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullSetLockStreamConstMeta,
      argValues: [sink],
      apiImpl: this,
    )));
    return sink.stream;
  }

  TaskConstMeta get kCrateApiFullSetLockStreamConstMeta => const TaskConstMeta(
        debugName: "set_lock_stream",
        argNames: ["sink"],
      );

  @override
  Stream<List<WalletEvent>> crateApiFullSetRecentHistoryStream() {
    final sink = RustStreamSink<List<WalletEvent>>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_StreamSink_list_wallet_event_Dco(sink);
        return wire.wire__crate__api__full__set_recent_history_stream(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullSetRecentHistoryStreamConstMeta,
      argValues: [sink],
      apiImpl: this,
    )));
    return sink.stream;
  }

  TaskConstMeta get kCrateApiFullSetRecentHistoryStreamConstMeta => const TaskConstMeta(
        debugName: "set_recent_history_stream",
        argNames: ["sink"],
      );

  @override
  Stream<FlutterVersionState> crateApiFullSetVersionStateStream() {
    final sink = RustStreamSink<FlutterVersionState>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_StreamSink_flutter_version_state_Dco(sink);
        return wire.wire__crate__api__full__set_version_state_stream(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFullSetVersionStateStreamConstMeta,
      argValues: [sink],
      apiImpl: this,
    )));
    return sink.stream;
  }

  TaskConstMeta get kCrateApiFullSetVersionStateStreamConstMeta => const TaskConstMeta(
        debugName: "set_version_state_stream",
        argNames: ["sink"],
      );

  @override
  Future<StartDisclosureResult> crateApiFullStartDisclosure({required String uri, required bool isQrCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(uri);
        var arg1 = cst_encode_bool(isQrCode);
        return wire.wire__crate__api__full__start_disclosure(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_start_disclosure_result,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullStartDisclosureConstMeta,
      argValues: [uri, isQrCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullStartDisclosureConstMeta => const TaskConstMeta(
        debugName: "start_disclosure",
        argNames: ["uri", "isQrCode"],
      );

  @override
  Future<WalletInstructionResult> crateApiFullUnlockWallet({required String pin}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(pin);
        return wire.wire__crate__api__full__unlock_wallet(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_wallet_instruction_result,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullUnlockWalletConstMeta,
      argValues: [pin],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullUnlockWalletConstMeta => const TaskConstMeta(
        debugName: "unlock_wallet",
        argNames: ["pin"],
      );

  @override
  Future<void> crateApiFullUnlockWalletWithBiometrics() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__full__unlock_wallet_with_biometrics(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiFullUnlockWalletWithBiometricsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFullUnlockWalletWithBiometricsConstMeta => const TaskConstMeta(
        debugName: "unlock_wallet_with_biometrics",
        argNames: [],
      );

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  RustStreamSink<bool> dco_decode_StreamSink_bool_Dco(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<FlutterConfiguration> dco_decode_StreamSink_flutter_configuration_Dco(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<FlutterVersionState> dco_decode_StreamSink_flutter_version_state_Dco(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<List<Card>> dco_decode_StreamSink_list_card_Dco(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<List<WalletEvent>> dco_decode_StreamSink_list_wallet_event_Dco(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AcceptDisclosureResult dco_decode_accept_disclosure_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return AcceptDisclosureResult_Ok(
          returnUrl: dco_decode_opt_String(raw[1]),
        );
      case 1:
        return AcceptDisclosureResult_InstructionError(
          error: dco_decode_box_autoadd_wallet_instruction_error(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  Card dco_decode_box_autoadd_card(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_card(raw);
  }

  @protected
  Image dco_decode_box_autoadd_image(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_image(raw);
  }

  @protected
  Organization dco_decode_box_autoadd_organization(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_organization(raw);
  }

  @protected
  RequestPolicy dco_decode_box_autoadd_request_policy(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_request_policy(raw);
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  WalletInstructionError dco_decode_box_autoadd_wallet_instruction_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_wallet_instruction_error(raw);
  }

  @protected
  Card dco_decode_card(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return Card(
      issuer: dco_decode_organization(arr[0]),
      persistence: dco_decode_card_persistence(arr[1]),
      docType: dco_decode_String(arr[2]),
      attributes: dco_decode_list_card_attribute(arr[3]),
    );
  }

  @protected
  CardAttribute dco_decode_card_attribute(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return CardAttribute(
      key: dco_decode_String(arr[0]),
      labels: dco_decode_list_localized_string(arr[1]),
      value: dco_decode_card_value(arr[2]),
    );
  }

  @protected
  CardPersistence dco_decode_card_persistence(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return CardPersistence_InMemory();
      case 1:
        return CardPersistence_Stored(
          id: dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  CardValue dco_decode_card_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return CardValue_String(
          value: dco_decode_String(raw[1]),
        );
      case 1:
        return CardValue_Boolean(
          value: dco_decode_bool(raw[1]),
        );
      case 2:
        return CardValue_Date(
          value: dco_decode_String(raw[1]),
        );
      case 3:
        return CardValue_Gender(
          value: dco_decode_gender_card_value(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  DisclosureCard dco_decode_disclosure_card(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return DisclosureCard(
      issuer: dco_decode_organization(arr[0]),
      docType: dco_decode_String(arr[1]),
      attributes: dco_decode_list_card_attribute(arr[2]),
    );
  }

  @protected
  DisclosureSessionType dco_decode_disclosure_session_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DisclosureSessionType.values[raw as int];
  }

  @protected
  DisclosureStatus dco_decode_disclosure_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DisclosureStatus.values[raw as int];
  }

  @protected
  DisclosureType dco_decode_disclosure_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DisclosureType.values[raw as int];
  }

  @protected
  FlutterConfiguration dco_decode_flutter_configuration(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return FlutterConfiguration(
      inactiveLockTimeout: dco_decode_u_16(arr[0]),
      backgroundLockTimeout: dco_decode_u_16(arr[1]),
      version: dco_decode_u_64(arr[2]),
    );
  }

  @protected
  FlutterVersionState dco_decode_flutter_version_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return FlutterVersionState_Ok();
      case 1:
        return FlutterVersionState_Notify();
      case 2:
        return FlutterVersionState_Recommend();
      case 3:
        return FlutterVersionState_Warn(
          expiresInSeconds: dco_decode_u_64(raw[1]),
        );
      case 4:
        return FlutterVersionState_Block();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  GenderCardValue dco_decode_gender_card_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return GenderCardValue.values[raw as int];
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  IdentifyUriResult dco_decode_identify_uri_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return IdentifyUriResult.values[raw as int];
  }

  @protected
  Image dco_decode_image(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Image_Svg(
          xml: dco_decode_String(raw[1]),
        );
      case 1:
        return Image_Png(
          base64: dco_decode_String(raw[1]),
        );
      case 2:
        return Image_Jpg(
          base64: dco_decode_String(raw[1]),
        );
      case 3:
        return Image_Asset(
          path: dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  List<Card> dco_decode_list_card(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_card).toList();
  }

  @protected
  List<CardAttribute> dco_decode_list_card_attribute(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_card_attribute).toList();
  }

  @protected
  List<DisclosureCard> dco_decode_list_disclosure_card(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_disclosure_card).toList();
  }

  @protected
  List<LocalizedString> dco_decode_list_localized_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_localized_string).toList();
  }

  @protected
  List<MissingAttribute> dco_decode_list_missing_attribute(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_missing_attribute).toList();
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<WalletEvent> dco_decode_list_wallet_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_wallet_event).toList();
  }

  @protected
  LocalizedString dco_decode_localized_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return LocalizedString(
      language: dco_decode_String(arr[0]),
      value: dco_decode_String(arr[1]),
    );
  }

  @protected
  MissingAttribute dco_decode_missing_attribute(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1) throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return MissingAttribute(
      labels: dco_decode_list_localized_string(arr[0]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  Image? dco_decode_opt_box_autoadd_image(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_image(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  List<DisclosureCard>? dco_decode_opt_list_disclosure_card(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_disclosure_card(raw);
  }

  @protected
  List<LocalizedString>? dco_decode_opt_list_localized_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_localized_string(raw);
  }

  @protected
  Organization dco_decode_organization(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11) throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return Organization(
      legalName: dco_decode_list_localized_string(arr[0]),
      displayName: dco_decode_list_localized_string(arr[1]),
      description: dco_decode_list_localized_string(arr[2]),
      image: dco_decode_opt_box_autoadd_image(arr[3]),
      webUrl: dco_decode_opt_String(arr[4]),
      privacyPolicyUrl: dco_decode_opt_String(arr[5]),
      kvk: dco_decode_opt_String(arr[6]),
      city: dco_decode_opt_list_localized_string(arr[7]),
      category: dco_decode_list_localized_string(arr[8]),
      department: dco_decode_opt_list_localized_string(arr[9]),
      countryCode: dco_decode_opt_String(arr[10]),
    );
  }

  @protected
  PinValidationResult dco_decode_pin_validation_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PinValidationResult.values[raw as int];
  }

  @protected
  RequestPolicy dco_decode_request_policy(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return RequestPolicy(
      dataStorageDurationInMinutes: dco_decode_opt_box_autoadd_u_64(arr[0]),
      dataSharedWithThirdParties: dco_decode_bool(arr[1]),
      dataDeletionPossible: dco_decode_bool(arr[2]),
      policyUrl: dco_decode_String(arr[3]),
    );
  }

  @protected
  StartDisclosureResult dco_decode_start_disclosure_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return StartDisclosureResult_Request(
          relyingParty: dco_decode_box_autoadd_organization(raw[1]),
          policy: dco_decode_box_autoadd_request_policy(raw[2]),
          requestedCards: dco_decode_list_disclosure_card(raw[3]),
          sharedDataWithRelyingPartyBefore: dco_decode_bool(raw[4]),
          sessionType: dco_decode_disclosure_session_type(raw[5]),
          requestPurpose: dco_decode_list_localized_string(raw[6]),
          requestOriginBaseUrl: dco_decode_String(raw[7]),
          requestType: dco_decode_disclosure_type(raw[8]),
        );
      case 1:
        return StartDisclosureResult_RequestAttributesMissing(
          relyingParty: dco_decode_box_autoadd_organization(raw[1]),
          missingAttributes: dco_decode_list_missing_attribute(raw[2]),
          sharedDataWithRelyingPartyBefore: dco_decode_bool(raw[3]),
          sessionType: dco_decode_disclosure_session_type(raw[4]),
          requestPurpose: dco_decode_list_localized_string(raw[5]),
          requestOriginBaseUrl: dco_decode_String(raw[6]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  WalletEvent dco_decode_wallet_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return WalletEvent_Disclosure(
          dateTime: dco_decode_String(raw[1]),
          relyingParty: dco_decode_box_autoadd_organization(raw[2]),
          purpose: dco_decode_list_localized_string(raw[3]),
          requestedCards: dco_decode_opt_list_disclosure_card(raw[4]),
          requestPolicy: dco_decode_box_autoadd_request_policy(raw[5]),
          status: dco_decode_disclosure_status(raw[6]),
          typ: dco_decode_disclosure_type(raw[7]),
        );
      case 1:
        return WalletEvent_Issuance(
          dateTime: dco_decode_String(raw[1]),
          card: dco_decode_box_autoadd_card(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  WalletInstructionError dco_decode_wallet_instruction_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return WalletInstructionError_IncorrectPin(
          attemptsLeftInRound: dco_decode_u_8(raw[1]),
          isFinalRound: dco_decode_bool(raw[2]),
        );
      case 1:
        return WalletInstructionError_Timeout(
          timeoutMillis: dco_decode_u_64(raw[1]),
        );
      case 2:
        return WalletInstructionError_Blocked();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  WalletInstructionResult dco_decode_wallet_instruction_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return WalletInstructionResult_Ok();
      case 1:
        return WalletInstructionResult_InstructionError(
          error: dco_decode_box_autoadd_wallet_instruction_error(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  RustStreamSink<bool> sse_decode_StreamSink_bool_Dco(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<FlutterConfiguration> sse_decode_StreamSink_flutter_configuration_Dco(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<FlutterVersionState> sse_decode_StreamSink_flutter_version_state_Dco(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<List<Card>> sse_decode_StreamSink_list_card_Dco(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<List<WalletEvent>> sse_decode_StreamSink_list_wallet_event_Dco(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AcceptDisclosureResult sse_decode_accept_disclosure_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_returnUrl = sse_decode_opt_String(deserializer);
        return AcceptDisclosureResult_Ok(returnUrl: var_returnUrl);
      case 1:
        var var_error = sse_decode_box_autoadd_wallet_instruction_error(deserializer);
        return AcceptDisclosureResult_InstructionError(error: var_error);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  Card sse_decode_box_autoadd_card(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_card(deserializer));
  }

  @protected
  Image sse_decode_box_autoadd_image(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_image(deserializer));
  }

  @protected
  Organization sse_decode_box_autoadd_organization(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_organization(deserializer));
  }

  @protected
  RequestPolicy sse_decode_box_autoadd_request_policy(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_request_policy(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  WalletInstructionError sse_decode_box_autoadd_wallet_instruction_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_wallet_instruction_error(deserializer));
  }

  @protected
  Card sse_decode_card(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_issuer = sse_decode_organization(deserializer);
    var var_persistence = sse_decode_card_persistence(deserializer);
    var var_docType = sse_decode_String(deserializer);
    var var_attributes = sse_decode_list_card_attribute(deserializer);
    return Card(issuer: var_issuer, persistence: var_persistence, docType: var_docType, attributes: var_attributes);
  }

  @protected
  CardAttribute sse_decode_card_attribute(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_key = sse_decode_String(deserializer);
    var var_labels = sse_decode_list_localized_string(deserializer);
    var var_value = sse_decode_card_value(deserializer);
    return CardAttribute(key: var_key, labels: var_labels, value: var_value);
  }

  @protected
  CardPersistence sse_decode_card_persistence(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return CardPersistence_InMemory();
      case 1:
        var var_id = sse_decode_String(deserializer);
        return CardPersistence_Stored(id: var_id);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  CardValue sse_decode_card_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_value = sse_decode_String(deserializer);
        return CardValue_String(value: var_value);
      case 1:
        var var_value = sse_decode_bool(deserializer);
        return CardValue_Boolean(value: var_value);
      case 2:
        var var_value = sse_decode_String(deserializer);
        return CardValue_Date(value: var_value);
      case 3:
        var var_value = sse_decode_gender_card_value(deserializer);
        return CardValue_Gender(value: var_value);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  DisclosureCard sse_decode_disclosure_card(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_issuer = sse_decode_organization(deserializer);
    var var_docType = sse_decode_String(deserializer);
    var var_attributes = sse_decode_list_card_attribute(deserializer);
    return DisclosureCard(issuer: var_issuer, docType: var_docType, attributes: var_attributes);
  }

  @protected
  DisclosureSessionType sse_decode_disclosure_session_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return DisclosureSessionType.values[inner];
  }

  @protected
  DisclosureStatus sse_decode_disclosure_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return DisclosureStatus.values[inner];
  }

  @protected
  DisclosureType sse_decode_disclosure_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return DisclosureType.values[inner];
  }

  @protected
  FlutterConfiguration sse_decode_flutter_configuration(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_inactiveLockTimeout = sse_decode_u_16(deserializer);
    var var_backgroundLockTimeout = sse_decode_u_16(deserializer);
    var var_version = sse_decode_u_64(deserializer);
    return FlutterConfiguration(
        inactiveLockTimeout: var_inactiveLockTimeout,
        backgroundLockTimeout: var_backgroundLockTimeout,
        version: var_version);
  }

  @protected
  FlutterVersionState sse_decode_flutter_version_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return FlutterVersionState_Ok();
      case 1:
        return FlutterVersionState_Notify();
      case 2:
        return FlutterVersionState_Recommend();
      case 3:
        var var_expiresInSeconds = sse_decode_u_64(deserializer);
        return FlutterVersionState_Warn(expiresInSeconds: var_expiresInSeconds);
      case 4:
        return FlutterVersionState_Block();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  GenderCardValue sse_decode_gender_card_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return GenderCardValue.values[inner];
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  IdentifyUriResult sse_decode_identify_uri_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return IdentifyUriResult.values[inner];
  }

  @protected
  Image sse_decode_image(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_xml = sse_decode_String(deserializer);
        return Image_Svg(xml: var_xml);
      case 1:
        var var_base64 = sse_decode_String(deserializer);
        return Image_Png(base64: var_base64);
      case 2:
        var var_base64 = sse_decode_String(deserializer);
        return Image_Jpg(base64: var_base64);
      case 3:
        var var_path = sse_decode_String(deserializer);
        return Image_Asset(path: var_path);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  List<Card> sse_decode_list_card(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Card>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_card(deserializer));
    }
    return ans_;
  }

  @protected
  List<CardAttribute> sse_decode_list_card_attribute(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <CardAttribute>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_card_attribute(deserializer));
    }
    return ans_;
  }

  @protected
  List<DisclosureCard> sse_decode_list_disclosure_card(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DisclosureCard>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_disclosure_card(deserializer));
    }
    return ans_;
  }

  @protected
  List<LocalizedString> sse_decode_list_localized_string(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LocalizedString>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_localized_string(deserializer));
    }
    return ans_;
  }

  @protected
  List<MissingAttribute> sse_decode_list_missing_attribute(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MissingAttribute>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_missing_attribute(deserializer));
    }
    return ans_;
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<WalletEvent> sse_decode_list_wallet_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <WalletEvent>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_wallet_event(deserializer));
    }
    return ans_;
  }

  @protected
  LocalizedString sse_decode_localized_string(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_language = sse_decode_String(deserializer);
    var var_value = sse_decode_String(deserializer);
    return LocalizedString(language: var_language, value: var_value);
  }

  @protected
  MissingAttribute sse_decode_missing_attribute(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_labels = sse_decode_list_localized_string(deserializer);
    return MissingAttribute(labels: var_labels);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Image? sse_decode_opt_box_autoadd_image(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_image(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<DisclosureCard>? sse_decode_opt_list_disclosure_card(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_disclosure_card(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<LocalizedString>? sse_decode_opt_list_localized_string(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_localized_string(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Organization sse_decode_organization(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_legalName = sse_decode_list_localized_string(deserializer);
    var var_displayName = sse_decode_list_localized_string(deserializer);
    var var_description = sse_decode_list_localized_string(deserializer);
    var var_image = sse_decode_opt_box_autoadd_image(deserializer);
    var var_webUrl = sse_decode_opt_String(deserializer);
    var var_privacyPolicyUrl = sse_decode_opt_String(deserializer);
    var var_kvk = sse_decode_opt_String(deserializer);
    var var_city = sse_decode_opt_list_localized_string(deserializer);
    var var_category = sse_decode_list_localized_string(deserializer);
    var var_department = sse_decode_opt_list_localized_string(deserializer);
    var var_countryCode = sse_decode_opt_String(deserializer);
    return Organization(
        legalName: var_legalName,
        displayName: var_displayName,
        description: var_description,
        image: var_image,
        webUrl: var_webUrl,
        privacyPolicyUrl: var_privacyPolicyUrl,
        kvk: var_kvk,
        city: var_city,
        category: var_category,
        department: var_department,
        countryCode: var_countryCode);
  }

  @protected
  PinValidationResult sse_decode_pin_validation_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PinValidationResult.values[inner];
  }

  @protected
  RequestPolicy sse_decode_request_policy(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_dataStorageDurationInMinutes = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_dataSharedWithThirdParties = sse_decode_bool(deserializer);
    var var_dataDeletionPossible = sse_decode_bool(deserializer);
    var var_policyUrl = sse_decode_String(deserializer);
    return RequestPolicy(
        dataStorageDurationInMinutes: var_dataStorageDurationInMinutes,
        dataSharedWithThirdParties: var_dataSharedWithThirdParties,
        dataDeletionPossible: var_dataDeletionPossible,
        policyUrl: var_policyUrl);
  }

  @protected
  StartDisclosureResult sse_decode_start_disclosure_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_relyingParty = sse_decode_box_autoadd_organization(deserializer);
        var var_policy = sse_decode_box_autoadd_request_policy(deserializer);
        var var_requestedCards = sse_decode_list_disclosure_card(deserializer);
        var var_sharedDataWithRelyingPartyBefore = sse_decode_bool(deserializer);
        var var_sessionType = sse_decode_disclosure_session_type(deserializer);
        var var_requestPurpose = sse_decode_list_localized_string(deserializer);
        var var_requestOriginBaseUrl = sse_decode_String(deserializer);
        var var_requestType = sse_decode_disclosure_type(deserializer);
        return StartDisclosureResult_Request(
            relyingParty: var_relyingParty,
            policy: var_policy,
            requestedCards: var_requestedCards,
            sharedDataWithRelyingPartyBefore: var_sharedDataWithRelyingPartyBefore,
            sessionType: var_sessionType,
            requestPurpose: var_requestPurpose,
            requestOriginBaseUrl: var_requestOriginBaseUrl,
            requestType: var_requestType);
      case 1:
        var var_relyingParty = sse_decode_box_autoadd_organization(deserializer);
        var var_missingAttributes = sse_decode_list_missing_attribute(deserializer);
        var var_sharedDataWithRelyingPartyBefore = sse_decode_bool(deserializer);
        var var_sessionType = sse_decode_disclosure_session_type(deserializer);
        var var_requestPurpose = sse_decode_list_localized_string(deserializer);
        var var_requestOriginBaseUrl = sse_decode_String(deserializer);
        return StartDisclosureResult_RequestAttributesMissing(
            relyingParty: var_relyingParty,
            missingAttributes: var_missingAttributes,
            sharedDataWithRelyingPartyBefore: var_sharedDataWithRelyingPartyBefore,
            sessionType: var_sessionType,
            requestPurpose: var_requestPurpose,
            requestOriginBaseUrl: var_requestOriginBaseUrl);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  WalletEvent sse_decode_wallet_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_dateTime = sse_decode_String(deserializer);
        var var_relyingParty = sse_decode_box_autoadd_organization(deserializer);
        var var_purpose = sse_decode_list_localized_string(deserializer);
        var var_requestedCards = sse_decode_opt_list_disclosure_card(deserializer);
        var var_requestPolicy = sse_decode_box_autoadd_request_policy(deserializer);
        var var_status = sse_decode_disclosure_status(deserializer);
        var var_typ = sse_decode_disclosure_type(deserializer);
        return WalletEvent_Disclosure(
            dateTime: var_dateTime,
            relyingParty: var_relyingParty,
            purpose: var_purpose,
            requestedCards: var_requestedCards,
            requestPolicy: var_requestPolicy,
            status: var_status,
            typ: var_typ);
      case 1:
        var var_dateTime = sse_decode_String(deserializer);
        var var_card = sse_decode_box_autoadd_card(deserializer);
        return WalletEvent_Issuance(dateTime: var_dateTime, card: var_card);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  WalletInstructionError sse_decode_wallet_instruction_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_attemptsLeftInRound = sse_decode_u_8(deserializer);
        var var_isFinalRound = sse_decode_bool(deserializer);
        return WalletInstructionError_IncorrectPin(
            attemptsLeftInRound: var_attemptsLeftInRound, isFinalRound: var_isFinalRound);
      case 1:
        var var_timeoutMillis = sse_decode_u_64(deserializer);
        return WalletInstructionError_Timeout(timeoutMillis: var_timeoutMillis);
      case 2:
        return WalletInstructionError_Blocked();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  WalletInstructionResult sse_decode_wallet_instruction_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return WalletInstructionResult_Ok();
      case 1:
        var var_error = sse_decode_box_autoadd_wallet_instruction_error(deserializer);
        return WalletInstructionResult_InstructionError(error: var_error);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_disclosure_session_type(DisclosureSessionType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_disclosure_status(DisclosureStatus raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_disclosure_type(DisclosureType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_gender_card_value(GenderCardValue raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_identify_uri_result(IdentifyUriResult raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_pin_validation_result(PinValidationResult raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_u_16(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void sse_encode_AnyhowException(AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_StreamSink_bool_Dco(RustStreamSink<bool> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: dco_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_flutter_configuration_Dco(
      RustStreamSink<FlutterConfiguration> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: DcoCodec(
          decodeSuccessData: dco_decode_flutter_configuration,
          decodeErrorData: dco_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_flutter_version_state_Dco(
      RustStreamSink<FlutterVersionState> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: DcoCodec(
          decodeSuccessData: dco_decode_flutter_version_state,
          decodeErrorData: dco_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_list_card_Dco(RustStreamSink<List<Card>> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: DcoCodec(
          decodeSuccessData: dco_decode_list_card,
          decodeErrorData: dco_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_list_wallet_event_Dco(RustStreamSink<List<WalletEvent>> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: DcoCodec(
          decodeSuccessData: dco_decode_list_wallet_event,
          decodeErrorData: dco_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_accept_disclosure_result(AcceptDisclosureResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case AcceptDisclosureResult_Ok(returnUrl: final returnUrl):
        sse_encode_i_32(0, serializer);
        sse_encode_opt_String(returnUrl, serializer);
      case AcceptDisclosureResult_InstructionError(error: final error):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_wallet_instruction_error(error, serializer);
    }
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_card(Card self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_card(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_image(Image self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_image(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_organization(Organization self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_organization(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_request_policy(RequestPolicy self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_request_policy(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_wallet_instruction_error(WalletInstructionError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_wallet_instruction_error(self, serializer);
  }

  @protected
  void sse_encode_card(Card self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_organization(self.issuer, serializer);
    sse_encode_card_persistence(self.persistence, serializer);
    sse_encode_String(self.docType, serializer);
    sse_encode_list_card_attribute(self.attributes, serializer);
  }

  @protected
  void sse_encode_card_attribute(CardAttribute self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.key, serializer);
    sse_encode_list_localized_string(self.labels, serializer);
    sse_encode_card_value(self.value, serializer);
  }

  @protected
  void sse_encode_card_persistence(CardPersistence self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case CardPersistence_InMemory():
        sse_encode_i_32(0, serializer);
      case CardPersistence_Stored(id: final id):
        sse_encode_i_32(1, serializer);
        sse_encode_String(id, serializer);
    }
  }

  @protected
  void sse_encode_card_value(CardValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case CardValue_String(value: final value):
        sse_encode_i_32(0, serializer);
        sse_encode_String(value, serializer);
      case CardValue_Boolean(value: final value):
        sse_encode_i_32(1, serializer);
        sse_encode_bool(value, serializer);
      case CardValue_Date(value: final value):
        sse_encode_i_32(2, serializer);
        sse_encode_String(value, serializer);
      case CardValue_Gender(value: final value):
        sse_encode_i_32(3, serializer);
        sse_encode_gender_card_value(value, serializer);
    }
  }

  @protected
  void sse_encode_disclosure_card(DisclosureCard self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_organization(self.issuer, serializer);
    sse_encode_String(self.docType, serializer);
    sse_encode_list_card_attribute(self.attributes, serializer);
  }

  @protected
  void sse_encode_disclosure_session_type(DisclosureSessionType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_disclosure_status(DisclosureStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_disclosure_type(DisclosureType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_flutter_configuration(FlutterConfiguration self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_16(self.inactiveLockTimeout, serializer);
    sse_encode_u_16(self.backgroundLockTimeout, serializer);
    sse_encode_u_64(self.version, serializer);
  }

  @protected
  void sse_encode_flutter_version_state(FlutterVersionState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case FlutterVersionState_Ok():
        sse_encode_i_32(0, serializer);
      case FlutterVersionState_Notify():
        sse_encode_i_32(1, serializer);
      case FlutterVersionState_Recommend():
        sse_encode_i_32(2, serializer);
      case FlutterVersionState_Warn(expiresInSeconds: final expiresInSeconds):
        sse_encode_i_32(3, serializer);
        sse_encode_u_64(expiresInSeconds, serializer);
      case FlutterVersionState_Block():
        sse_encode_i_32(4, serializer);
    }
  }

  @protected
  void sse_encode_gender_card_value(GenderCardValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_identify_uri_result(IdentifyUriResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_image(Image self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Image_Svg(xml: final xml):
        sse_encode_i_32(0, serializer);
        sse_encode_String(xml, serializer);
      case Image_Png(base64: final base64):
        sse_encode_i_32(1, serializer);
        sse_encode_String(base64, serializer);
      case Image_Jpg(base64: final base64):
        sse_encode_i_32(2, serializer);
        sse_encode_String(base64, serializer);
      case Image_Asset(path: final path):
        sse_encode_i_32(3, serializer);
        sse_encode_String(path, serializer);
    }
  }

  @protected
  void sse_encode_list_card(List<Card> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_card(item, serializer);
    }
  }

  @protected
  void sse_encode_list_card_attribute(List<CardAttribute> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_card_attribute(item, serializer);
    }
  }

  @protected
  void sse_encode_list_disclosure_card(List<DisclosureCard> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_disclosure_card(item, serializer);
    }
  }

  @protected
  void sse_encode_list_localized_string(List<LocalizedString> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_localized_string(item, serializer);
    }
  }

  @protected
  void sse_encode_list_missing_attribute(List<MissingAttribute> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_missing_attribute(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_strict(Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_wallet_event(List<WalletEvent> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_wallet_event(item, serializer);
    }
  }

  @protected
  void sse_encode_localized_string(LocalizedString self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.language, serializer);
    sse_encode_String(self.value, serializer);
  }

  @protected
  void sse_encode_missing_attribute(MissingAttribute self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_localized_string(self.labels, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_image(Image? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_image(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_disclosure_card(List<DisclosureCard>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_disclosure_card(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_localized_string(List<LocalizedString>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_localized_string(self, serializer);
    }
  }

  @protected
  void sse_encode_organization(Organization self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_localized_string(self.legalName, serializer);
    sse_encode_list_localized_string(self.displayName, serializer);
    sse_encode_list_localized_string(self.description, serializer);
    sse_encode_opt_box_autoadd_image(self.image, serializer);
    sse_encode_opt_String(self.webUrl, serializer);
    sse_encode_opt_String(self.privacyPolicyUrl, serializer);
    sse_encode_opt_String(self.kvk, serializer);
    sse_encode_opt_list_localized_string(self.city, serializer);
    sse_encode_list_localized_string(self.category, serializer);
    sse_encode_opt_list_localized_string(self.department, serializer);
    sse_encode_opt_String(self.countryCode, serializer);
  }

  @protected
  void sse_encode_pin_validation_result(PinValidationResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_request_policy(RequestPolicy self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_u_64(self.dataStorageDurationInMinutes, serializer);
    sse_encode_bool(self.dataSharedWithThirdParties, serializer);
    sse_encode_bool(self.dataDeletionPossible, serializer);
    sse_encode_String(self.policyUrl, serializer);
  }

  @protected
  void sse_encode_start_disclosure_result(StartDisclosureResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case StartDisclosureResult_Request(
          relyingParty: final relyingParty,
          policy: final policy,
          requestedCards: final requestedCards,
          sharedDataWithRelyingPartyBefore: final sharedDataWithRelyingPartyBefore,
          sessionType: final sessionType,
          requestPurpose: final requestPurpose,
          requestOriginBaseUrl: final requestOriginBaseUrl,
          requestType: final requestType
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_organization(relyingParty, serializer);
        sse_encode_box_autoadd_request_policy(policy, serializer);
        sse_encode_list_disclosure_card(requestedCards, serializer);
        sse_encode_bool(sharedDataWithRelyingPartyBefore, serializer);
        sse_encode_disclosure_session_type(sessionType, serializer);
        sse_encode_list_localized_string(requestPurpose, serializer);
        sse_encode_String(requestOriginBaseUrl, serializer);
        sse_encode_disclosure_type(requestType, serializer);
      case StartDisclosureResult_RequestAttributesMissing(
          relyingParty: final relyingParty,
          missingAttributes: final missingAttributes,
          sharedDataWithRelyingPartyBefore: final sharedDataWithRelyingPartyBefore,
          sessionType: final sessionType,
          requestPurpose: final requestPurpose,
          requestOriginBaseUrl: final requestOriginBaseUrl
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_organization(relyingParty, serializer);
        sse_encode_list_missing_attribute(missingAttributes, serializer);
        sse_encode_bool(sharedDataWithRelyingPartyBefore, serializer);
        sse_encode_disclosure_session_type(sessionType, serializer);
        sse_encode_list_localized_string(requestPurpose, serializer);
        sse_encode_String(requestOriginBaseUrl, serializer);
    }
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_wallet_event(WalletEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case WalletEvent_Disclosure(
          dateTime: final dateTime,
          relyingParty: final relyingParty,
          purpose: final purpose,
          requestedCards: final requestedCards,
          requestPolicy: final requestPolicy,
          status: final status,
          typ: final typ
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_String(dateTime, serializer);
        sse_encode_box_autoadd_organization(relyingParty, serializer);
        sse_encode_list_localized_string(purpose, serializer);
        sse_encode_opt_list_disclosure_card(requestedCards, serializer);
        sse_encode_box_autoadd_request_policy(requestPolicy, serializer);
        sse_encode_disclosure_status(status, serializer);
        sse_encode_disclosure_type(typ, serializer);
      case WalletEvent_Issuance(dateTime: final dateTime, card: final card):
        sse_encode_i_32(1, serializer);
        sse_encode_String(dateTime, serializer);
        sse_encode_box_autoadd_card(card, serializer);
    }
  }

  @protected
  void sse_encode_wallet_instruction_error(WalletInstructionError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case WalletInstructionError_IncorrectPin(
          attemptsLeftInRound: final attemptsLeftInRound,
          isFinalRound: final isFinalRound
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_u_8(attemptsLeftInRound, serializer);
        sse_encode_bool(isFinalRound, serializer);
      case WalletInstructionError_Timeout(timeoutMillis: final timeoutMillis):
        sse_encode_i_32(1, serializer);
        sse_encode_u_64(timeoutMillis, serializer);
      case WalletInstructionError_Blocked():
        sse_encode_i_32(2, serializer);
    }
  }

  @protected
  void sse_encode_wallet_instruction_result(WalletInstructionResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case WalletInstructionResult_Ok():
        sse_encode_i_32(0, serializer);
      case WalletInstructionResult_InstructionError(error: final error):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_wallet_instruction_error(error, serializer);
    }
  }
}
