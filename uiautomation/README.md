# NL Wallet UI Automation framework

This framework is for automating the Android and iOS NL-Wallet app in a single
code base using Appium and BrowserStack.

## Contents

- [Prerequisites for installation on MacOS](#prerequisites-for-installation-on-macos)
- [Appium Setup](#appium-setup)
- [Run Automation Tests](#run-automation-tests)
- [Test Annotations](#test-annotations)

## Prerequisites for installation on MacOS

1. Install Java SE Development Kit 11 or later.
   https://www.oracle.com/java/technologies/downloads/#java11</b>
2. Set JAVA_HOME in your environment variable:
   `export JAVA_HOME=$(/usr/libexec/java_home) export PATH=$JAVA_HOME/bin:$PATH`.
3. `Node & NPM`</b> - Download & install node from
   `https://nodejs.org/en/download/`.
4. `Gradle`</b> - Install Gradle.
5. `Android`</b> - Install Android Studio & set <i><b>ANDROID_HOME</b></i> path.
    - Downloading the Android SDK
    - Download the Android SDK tools such as
        1. Build tools
        2. Platform tools
        3. Android Emulator
        4. Create an emulator device with API version 33 from AVD manager
6. `iOS`</b> - Install XCode on your machine & download required iPhone/iPad
   simulators.

## Appium Setup

1. Install [Appium](https://appium.io/docs/en/2.0/quickstart/install/):
   `npm i --location=global appium`
2. Install
   [Appium uiautomator2 Driver](https://github.com/appium-userland/appium-uiautomator2-driver):
   `appium driver install --source=npm uiautomator2`
3. Install
   [Appium xcuitest Driver](https://github.com/appium/appium-xcuitest-driver):
   `appium driver install --source=npm xcuitest`
4. Verify setup by running: `appium doctor`

## Run Automation Tests

### Preconditions

1. Make sure that you are in the correct directory: `uiautomation` where the
   Gradle project is located.
2. See "[Customizing the test run](#customizing-test-runs)" for more info on how
   to customize & run test locally or remote.

### Local run

#### Preconditions

- Have an Android with support for
  [Application integrity](https://developer.android.com/google/play/integrity/verdicts#application-integrity-field)
- An IOS device
- First, fetch the dependencies by running `flutter pub get`
- Replace in wallet_core/wallet the files `config-server-config.json` &
  `wallet-config.json` with the files `config-server-config.json` &
  `wallet-config.json` generated by job `wallet-config-ont` of the main pipeline
- Donwload `key.properties` and `keystore/local-keystore.jks` for Android signing
  and put it in wallet_app/android
- and then create an APK by executing
  `CONFIG_ENV=ont UNIVERSAL_LINK_BASE=https://app.example.com/deeplink/ bundle exec fastlane android build build_mode:release file_format:apk demo_index_url:https://example.com/ universal_link_base:app.example.com`.
- and then create an IPA by executing
  `CONFIG_ENV="ont" UL_HOSTNAME=app.example.com UNIVERSAL_LINK_BASE="https://app.example.com/deeplink/" bundle exec fastlane ios build app_store:false build_mode:release demo_index_url:https://example.com/ universal_link_base:app.example.com`.
- Above commands creates apps that run against the test environment.
- For IOS the value of variable ipaPath in
  `uiautomation/src/main/kotlin/driver/LocalMobileDriver.kt` needs to be changed
  to the location of the IPA build with the previous command.
- For IOS additional driver capabilities must be set to run the test on a real
  device. This can be done by filling the values in
  `uiautomation/src/main/kotlin/driver/LocalMobileDriver.kt` for the following
  capabilities: `udid`, `xcodeOrgId`, `xcodeSigningId`, `updatedWDABundleId`

The Appium Server will start automatically. Appium Server will handle the
process of running the tests and displaying the results on the console.

### BrowserStack run

#### Precondition

- Add the following environment variables to the `~/.bash_profile` or `~/.zshrc`
  file:
    - `export BROWSERSTACK_USER={USERNAME}`
    - `export BROWSERSTACK_KEY={ACCESS_KEY}`
- Build the app(s):
    - and Android APK:
      `CONFIG_ENV=ont UNIVERSAL_LINK_BASE=https://app.example.com/deeplink/ bundle exec fastlane android build build_mode:release file_format:apk demo_index_url:https://example.com/ universal_link_base:app.example.com`
    - and iOS IPA:
      `CONFIG_ENV="ont" UL_HOSTNAME=app.example.com UNIVERSAL_LINK_BASE="https://app.example.com/deeplink/" bundle exec fastlane ios build app_store:false build_mode:release demo_index_url:https://example.com/ universal_link_base:app.example.com`
- Manually upload the app(s) to BrowserStack, see
  [upload app from filesystem](https://www.browserstack.com/docs/app-automate/appium/upload-app-from-filesystem).

This will run the all the tests and output the test execution results on
[App Automate dashboard](https://app-automate.browserstack.com/dashboard).

### Customizing local test runs

The following parameters can be used to customize the test run:

1. `test.config.app.identifier`; The identifier of the app to be tested, being
   the package name for Android or the bundle ID for iOS.
2. `test.config.device.name`; The name of the device to be used for testing, use
   your local device for Android testing.
3. `test.config.platform.name`; The name of the platform to be used for testing,
   use `android` for local Android testing.
4. `test.config.platform.version`; The version of the platform to be used for
   testing, set this to the Android version of the device.
5. `test.config.remote`; The value of this parameter should be set to `false` to
   run the tests locally, else `true` for BrowserStack test runs.
6. `test.config.automation.name`; The value of this parameter should be set to
   `UIAutomator2` for Android.

#### Local test run examples:

Smoke test run example:

```bash
./gradlew smokeTest
```

Full test suite run example:

```bash
./gradlew test --tests suite.FullTestSuite
    -Dtest.config.app.identifier="nl.ictu.edi.wallet.latest"
    -Dtest.config.device.name="emulator-5554"
    -Dtest.config.platform.name="Android"
    -Dtest.config.platform.version="14.0"
    -Dtest.config.remote=false
    -Dtest.config.automation.name="UIAutomator2"
```

### Customizing Browserstack test runs

The e2e testframework uses the Browserstack SDK to run test against
browserstack. The SDK looks in the root of the `uiautomation` directory for a
config file named `browserstack.yml` in which most capabilities are set. For
running on a Oneplus 12r the file at
`uiautomation/browserstack-config/browserstack-oneplus12r-14-NL.yml` can be moved
to `uiautomation/browserstack.yml`. When running with `-Dtest.config.remote=true`
this config will be picked up. It is necessary to export both the APP_IDENTIFIER
and CI_COMMIT_SHA env vars in order for the tests to run. For the latter this
can either be set to the commit sha of a commit on main on which the pipeline
has run and thus has uploaded an app to browserstack. Alternatively you can
upload an app manually to browserstack in different ways described
[here](https://www.browserstack.com/docs/app-automate/appium/set-up-test-env/upload-and-manage-apps).
For different approaches the `app` value in the `browserstack.yml` should be set
differently, this and other features of the browserstack SDK are documented
[on the Browserstack site](https://www.browserstack.com/docs/app-automate/appium/sdk-benefits).

Remote test run example:

```bash
./gradlew test --tests suite.FullTestSuite
    -Dtest.config.remote=true
```

## Test Annotations

JUnit 5 provides a variety of test annotations that offer capabilities for
organizing and configuring tests. These annotations allow you to customize the
behavior of your tests and provide additional context or information.

### @RetryingTest

#### @RetryingTest(value = n, name = "{displayName} - #{index}")

The @RetryingTest annotation allows for retrying tests that may fail due to
external systems or other factors beyond the control of the code under test.
This feature is particularly useful in cases where avoiding such failures is not
feasible.

By applying the @RetryingTest annotation with the following attributes, you can
control the behavior of the retry mechanism:

- The value attribute specifies the number of times the test will be executed
  before giving up.
- The name attribute determines the display name for each individual test
  invocation.
- The index attribute will be replaced with the current invocation index.

### @Tag

#### @Tags(Tag("smoke"), Tag("android"), Tag("ios"))

The @Tag annotation allows you to assign tags to your test classes or methods.
These tags can then be used for filtering, allowing you to selectively run
specific tests based on the desired criteria.

### @Suite

The @Suite annotation allows you to create test suites to execute tests spread
across multiple classes and packages. A test suite is a logical grouping of
tests that provides a convenient way to organize and execute related tests
together.

```
@SelectPackages("feature")
@Suite
@SuiteDisplayName("Feature test suite")
object FeatureTestSuite {
}
```

The code snippet provided utilizes annotations to define a test suite called
"RunTests" that includes all tests within the "feature" package. Here's what
each annotation does:

- @SelectPackages("feature"): This annotation specifies that only the tests
  within the "feature" package should be included in the test suite. It acts as
  a filter, ensuring that only tests within the specified package are executed.
- @Suite: This annotation marks the class as a test suite. It indicates that the
  class is responsible for defining and executing a suite of tests rather than
  being a regular test class.
- @SuiteDisplayName("Run all tests"): This annotation assigns a display name to
  the test suite. In this case, the display name is set as "Run all tests,"
  which provides a descriptive name for the suite, indicating that it
  encompasses all tests within the "feature" package.
