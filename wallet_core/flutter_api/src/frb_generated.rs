// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.7.1.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = DcoCodec,
    default_rust_opaque = RustOpaqueNom,
    default_rust_auto_opaque = RustAutoOpaqueNom,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.7.1";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -580739876;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__full__accept_disclosure_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    pin: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "accept_disclosure",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_pin = pin.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>((move || {
                    let output_ok = crate::api::full::accept_disclosure(api_pin)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__full__accept_pid_issuance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    pin: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "accept_pid_issuance",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_pin = pin.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>((move || {
                    let output_ok = crate::api::full::accept_pid_issuance(api_pin)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__full__cancel_disclosure_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cancel_disclosure",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::cancel_disclosure().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__cancel_pid_issuance_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cancel_pid_issuance",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::cancel_pid_issuance().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__change_pin_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    old_pin: impl CstDecode<String>,
    new_pin: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "change_pin",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_old_pin = old_pin.cst_decode();
            let api_new_pin = new_pin.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::change_pin(api_old_pin, api_new_pin).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__check_pin_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    pin: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "check_pin",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_pin = pin.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::check_pin(api_pin).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__clear_cards_stream_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "clear_cards_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::full::clear_cards_stream().await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__clear_configuration_stream_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "clear_configuration_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::full::clear_configuration_stream().await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__clear_lock_stream_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "clear_lock_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::full::clear_lock_stream().await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__clear_recent_history_stream_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "clear_recent_history_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::full::clear_recent_history_stream().await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__clear_version_state_stream_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "clear_version_state_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::full::clear_version_state_stream().await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__continue_change_pin_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    pin: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "continue_change_pin",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_pin = pin.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::continue_change_pin(api_pin).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__continue_pid_issuance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    uri: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "continue_pid_issuance",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_uri = uri.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::continue_pid_issuance(api_uri).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__create_pid_issuance_redirect_uri_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_pid_issuance_redirect_uri",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::create_pid_issuance_redirect_uri().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__get_history_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_history",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::get_history().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__get_history_for_card_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    doc_type: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_history_for_card",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_doc_type = doc_type.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::get_history_for_card(api_doc_type).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__get_version_string_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_version_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::full::get_version_string())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__full__has_active_disclosure_session_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "has_active_disclosure_session",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::has_active_disclosure_session().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__has_active_pid_issuance_session_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "has_active_pid_issuance_session",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::has_active_pid_issuance_session().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__has_registration_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "has_registration",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(crate::api::full::has_registration().await)?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__identify_uri_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    uri: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "identify_uri",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_uri = uri.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::identify_uri(api_uri).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__init_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::init().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__is_biometric_unlock_enabled_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_biometric_unlock_enabled",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::is_biometric_unlock_enabled().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__is_initialized_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_initialized",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::full::is_initialized())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__full__is_valid_pin_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    pin: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_valid_pin",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_pin = pin.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>((move || {
                    let output_ok = crate::api::full::is_valid_pin(api_pin)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__full__lock_wallet_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lock_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::full::lock_wallet().await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__register_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    pin: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "register",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_pin = pin.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::register(api_pin).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__reset_wallet_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "reset_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::reset_wallet().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__set_biometric_unlock_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    enable: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_biometric_unlock",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_enable = enable.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::set_biometric_unlock(api_enable).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__set_cards_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    sink: impl CstDecode<StreamSink<Vec<crate::models::card::Card>, flutter_rust_bridge::for_generated::DcoCodec>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_cards_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_sink = sink.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::set_cards_stream(api_sink).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__set_configuration_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    sink: impl CstDecode<
        StreamSink<crate::models::config::FlutterConfiguration, flutter_rust_bridge::for_generated::DcoCodec>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_configuration_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_sink = sink.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::full::set_configuration_stream(api_sink).await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__set_lock_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    sink: impl CstDecode<StreamSink<bool, flutter_rust_bridge::for_generated::DcoCodec>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_lock_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_sink = sink.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::full::set_lock_stream(api_sink).await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__set_recent_history_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    sink: impl CstDecode<
        StreamSink<Vec<crate::models::wallet_event::WalletEvent>, flutter_rust_bridge::for_generated::DcoCodec>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_recent_history_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_sink = sink.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::set_recent_history_stream(api_sink).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__set_version_state_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    sink: impl CstDecode<
        StreamSink<crate::models::version_state::FlutterVersionState, flutter_rust_bridge::for_generated::DcoCodec>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_version_state_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_sink = sink.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::full::set_version_state_stream(api_sink).await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__start_disclosure_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    uri: impl CstDecode<String>,
    is_qr_code: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "start_disclosure",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_uri = uri.cst_decode();
            let api_is_qr_code = is_qr_code.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::start_disclosure(api_uri, api_is_qr_code).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__unlock_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    pin: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "unlock_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_pin = pin.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::unlock_wallet(api_pin).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__full__unlock_wallet_with_biometrics_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "unlock_wallet_with_biometrics",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| async move {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::full::unlock_wallet_with_biometrics().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}

// Section: dart2rust

impl CstDecode<bool> for bool {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<crate::models::disclosure::DisclosureSessionType> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::models::disclosure::DisclosureSessionType {
        match self {
            0 => crate::models::disclosure::DisclosureSessionType::SameDevice,
            1 => crate::models::disclosure::DisclosureSessionType::CrossDevice,
            _ => unreachable!("Invalid variant for DisclosureSessionType: {}", self),
        }
    }
}
impl CstDecode<crate::models::disclosure::DisclosureStatus> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::models::disclosure::DisclosureStatus {
        match self {
            0 => crate::models::disclosure::DisclosureStatus::Success,
            1 => crate::models::disclosure::DisclosureStatus::Cancelled,
            2 => crate::models::disclosure::DisclosureStatus::Error,
            _ => unreachable!("Invalid variant for DisclosureStatus: {}", self),
        }
    }
}
impl CstDecode<crate::models::disclosure::DisclosureType> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::models::disclosure::DisclosureType {
        match self {
            0 => crate::models::disclosure::DisclosureType::Login,
            1 => crate::models::disclosure::DisclosureType::Regular,
            _ => unreachable!("Invalid variant for DisclosureType: {}", self),
        }
    }
}
impl CstDecode<crate::models::card::GenderCardValue> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::models::card::GenderCardValue {
        match self {
            0 => crate::models::card::GenderCardValue::Unknown,
            1 => crate::models::card::GenderCardValue::Male,
            2 => crate::models::card::GenderCardValue::Female,
            3 => crate::models::card::GenderCardValue::NotApplicable,
            _ => unreachable!("Invalid variant for GenderCardValue: {}", self),
        }
    }
}
impl CstDecode<i32> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i32 {
        self
    }
}
impl CstDecode<crate::models::uri::IdentifyUriResult> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::models::uri::IdentifyUriResult {
        match self {
            0 => crate::models::uri::IdentifyUriResult::PidIssuance,
            1 => crate::models::uri::IdentifyUriResult::Disclosure,
            _ => unreachable!("Invalid variant for IdentifyUriResult: {}", self),
        }
    }
}
impl CstDecode<crate::models::pin::PinValidationResult> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::models::pin::PinValidationResult {
        match self {
            0 => crate::models::pin::PinValidationResult::Ok,
            1 => crate::models::pin::PinValidationResult::TooFewUniqueDigits,
            2 => crate::models::pin::PinValidationResult::SequentialDigits,
            3 => crate::models::pin::PinValidationResult::OtherIssue,
            _ => unreachable!("Invalid variant for PinValidationResult: {}", self),
        }
    }
}
impl CstDecode<u16> for u16 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u16 {
        self
    }
}
impl CstDecode<u64> for u64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u64 {
        self
    }
}
impl CstDecode<u8> for u8 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u8 {
        self
    }
}
impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for StreamSink<bool, flutter_rust_bridge::for_generated::DcoCodec> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<crate::models::config::FlutterConfiguration, flutter_rust_bridge::for_generated::DcoCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<crate::models::version_state::FlutterVersionState, flutter_rust_bridge::for_generated::DcoCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode for StreamSink<Vec<crate::models::card::Card>, flutter_rust_bridge::for_generated::DcoCodec> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<Vec<crate::models::wallet_event::WalletEvent>, flutter_rust_bridge::for_generated::DcoCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::models::disclosure::AcceptDisclosureResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_returnUrl = <Option<String>>::sse_decode(deserializer);
                return crate::models::disclosure::AcceptDisclosureResult::Ok {
                    return_url: var_returnUrl,
                };
            }
            1 => {
                let mut var_error = <crate::models::instruction::WalletInstructionError>::sse_decode(deserializer);
                return crate::models::disclosure::AcceptDisclosureResult::InstructionError { error: var_error };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::models::card::Card {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_issuer = <crate::models::disclosure::Organization>::sse_decode(deserializer);
        let mut var_persistence = <crate::models::card::CardPersistence>::sse_decode(deserializer);
        let mut var_docType = <String>::sse_decode(deserializer);
        let mut var_attributes = <Vec<crate::models::card::CardAttribute>>::sse_decode(deserializer);
        return crate::models::card::Card {
            issuer: var_issuer,
            persistence: var_persistence,
            doc_type: var_docType,
            attributes: var_attributes,
        };
    }
}

impl SseDecode for crate::models::card::CardAttribute {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_key = <String>::sse_decode(deserializer);
        let mut var_labels = <Vec<crate::models::card::LocalizedString>>::sse_decode(deserializer);
        let mut var_value = <crate::models::card::CardValue>::sse_decode(deserializer);
        return crate::models::card::CardAttribute {
            key: var_key,
            labels: var_labels,
            value: var_value,
        };
    }
}

impl SseDecode for crate::models::card::CardPersistence {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::models::card::CardPersistence::InMemory;
            }
            1 => {
                let mut var_id = <String>::sse_decode(deserializer);
                return crate::models::card::CardPersistence::Stored { id: var_id };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::card::CardValue {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_value = <String>::sse_decode(deserializer);
                return crate::models::card::CardValue::String { value: var_value };
            }
            1 => {
                let mut var_value = <bool>::sse_decode(deserializer);
                return crate::models::card::CardValue::Boolean { value: var_value };
            }
            2 => {
                let mut var_value = <String>::sse_decode(deserializer);
                return crate::models::card::CardValue::Date { value: var_value };
            }
            3 => {
                let mut var_value = <crate::models::card::GenderCardValue>::sse_decode(deserializer);
                return crate::models::card::CardValue::Gender { value: var_value };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::disclosure::DisclosureCard {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_issuer = <crate::models::disclosure::Organization>::sse_decode(deserializer);
        let mut var_docType = <String>::sse_decode(deserializer);
        let mut var_attributes = <Vec<crate::models::card::CardAttribute>>::sse_decode(deserializer);
        return crate::models::disclosure::DisclosureCard {
            issuer: var_issuer,
            doc_type: var_docType,
            attributes: var_attributes,
        };
    }
}

impl SseDecode for crate::models::disclosure::DisclosureSessionType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::disclosure::DisclosureSessionType::SameDevice,
            1 => crate::models::disclosure::DisclosureSessionType::CrossDevice,
            _ => unreachable!("Invalid variant for DisclosureSessionType: {}", inner),
        };
    }
}

impl SseDecode for crate::models::disclosure::DisclosureStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::disclosure::DisclosureStatus::Success,
            1 => crate::models::disclosure::DisclosureStatus::Cancelled,
            2 => crate::models::disclosure::DisclosureStatus::Error,
            _ => unreachable!("Invalid variant for DisclosureStatus: {}", inner),
        };
    }
}

impl SseDecode for crate::models::disclosure::DisclosureType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::disclosure::DisclosureType::Login,
            1 => crate::models::disclosure::DisclosureType::Regular,
            _ => unreachable!("Invalid variant for DisclosureType: {}", inner),
        };
    }
}

impl SseDecode for crate::models::config::FlutterConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_inactiveLockTimeout = <u16>::sse_decode(deserializer);
        let mut var_backgroundLockTimeout = <u16>::sse_decode(deserializer);
        let mut var_version = <u64>::sse_decode(deserializer);
        return crate::models::config::FlutterConfiguration {
            inactive_lock_timeout: var_inactiveLockTimeout,
            background_lock_timeout: var_backgroundLockTimeout,
            version: var_version,
        };
    }
}

impl SseDecode for crate::models::version_state::FlutterVersionState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::models::version_state::FlutterVersionState::Ok;
            }
            1 => {
                return crate::models::version_state::FlutterVersionState::Notify;
            }
            2 => {
                return crate::models::version_state::FlutterVersionState::Recommend;
            }
            3 => {
                let mut var_expiresInSeconds = <u64>::sse_decode(deserializer);
                return crate::models::version_state::FlutterVersionState::Warn {
                    expires_in_seconds: var_expiresInSeconds,
                };
            }
            4 => {
                return crate::models::version_state::FlutterVersionState::Block;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::card::GenderCardValue {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::card::GenderCardValue::Unknown,
            1 => crate::models::card::GenderCardValue::Male,
            2 => crate::models::card::GenderCardValue::Female,
            3 => crate::models::card::GenderCardValue::NotApplicable,
            _ => unreachable!("Invalid variant for GenderCardValue: {}", inner),
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::models::uri::IdentifyUriResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::uri::IdentifyUriResult::PidIssuance,
            1 => crate::models::uri::IdentifyUriResult::Disclosure,
            _ => unreachable!("Invalid variant for IdentifyUriResult: {}", inner),
        };
    }
}

impl SseDecode for crate::models::disclosure::Image {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_xml = <String>::sse_decode(deserializer);
                return crate::models::disclosure::Image::Svg { xml: var_xml };
            }
            1 => {
                let mut var_base64 = <String>::sse_decode(deserializer);
                return crate::models::disclosure::Image::Png { base64: var_base64 };
            }
            2 => {
                let mut var_base64 = <String>::sse_decode(deserializer);
                return crate::models::disclosure::Image::Jpg { base64: var_base64 };
            }
            3 => {
                let mut var_path = <String>::sse_decode(deserializer);
                return crate::models::disclosure::Image::Asset { path: var_path };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for Vec<crate::models::card::Card> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::card::Card>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::card::CardAttribute> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::card::CardAttribute>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::disclosure::DisclosureCard> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::disclosure::DisclosureCard>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::card::LocalizedString> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::card::LocalizedString>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::disclosure::MissingAttribute> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::disclosure::MissingAttribute>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::wallet_event::WalletEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::wallet_event::WalletEvent>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::models::card::LocalizedString {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_language = <String>::sse_decode(deserializer);
        let mut var_value = <String>::sse_decode(deserializer);
        return crate::models::card::LocalizedString {
            language: var_language,
            value: var_value,
        };
    }
}

impl SseDecode for crate::models::disclosure::MissingAttribute {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_labels = <Vec<crate::models::card::LocalizedString>>::sse_decode(deserializer);
        return crate::models::disclosure::MissingAttribute { labels: var_labels };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::disclosure::Image> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::disclosure::Image>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::models::disclosure::DisclosureCard>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<crate::models::disclosure::DisclosureCard>>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::models::card::LocalizedString>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<crate::models::card::LocalizedString>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::models::disclosure::Organization {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_legalName = <Vec<crate::models::card::LocalizedString>>::sse_decode(deserializer);
        let mut var_displayName = <Vec<crate::models::card::LocalizedString>>::sse_decode(deserializer);
        let mut var_description = <Vec<crate::models::card::LocalizedString>>::sse_decode(deserializer);
        let mut var_image = <Option<crate::models::disclosure::Image>>::sse_decode(deserializer);
        let mut var_webUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_privacyPolicyUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_kvk = <Option<String>>::sse_decode(deserializer);
        let mut var_city = <Option<Vec<crate::models::card::LocalizedString>>>::sse_decode(deserializer);
        let mut var_category = <Vec<crate::models::card::LocalizedString>>::sse_decode(deserializer);
        let mut var_department = <Option<Vec<crate::models::card::LocalizedString>>>::sse_decode(deserializer);
        let mut var_countryCode = <Option<String>>::sse_decode(deserializer);
        return crate::models::disclosure::Organization {
            legal_name: var_legalName,
            display_name: var_displayName,
            description: var_description,
            image: var_image,
            web_url: var_webUrl,
            privacy_policy_url: var_privacyPolicyUrl,
            kvk: var_kvk,
            city: var_city,
            category: var_category,
            department: var_department,
            country_code: var_countryCode,
        };
    }
}

impl SseDecode for crate::models::pin::PinValidationResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::pin::PinValidationResult::Ok,
            1 => crate::models::pin::PinValidationResult::TooFewUniqueDigits,
            2 => crate::models::pin::PinValidationResult::SequentialDigits,
            3 => crate::models::pin::PinValidationResult::OtherIssue,
            _ => unreachable!("Invalid variant for PinValidationResult: {}", inner),
        };
    }
}

impl SseDecode for crate::models::disclosure::RequestPolicy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_dataStorageDurationInMinutes = <Option<u64>>::sse_decode(deserializer);
        let mut var_dataSharedWithThirdParties = <bool>::sse_decode(deserializer);
        let mut var_dataDeletionPossible = <bool>::sse_decode(deserializer);
        let mut var_policyUrl = <String>::sse_decode(deserializer);
        return crate::models::disclosure::RequestPolicy {
            data_storage_duration_in_minutes: var_dataStorageDurationInMinutes,
            data_shared_with_third_parties: var_dataSharedWithThirdParties,
            data_deletion_possible: var_dataDeletionPossible,
            policy_url: var_policyUrl,
        };
    }
}

impl SseDecode for crate::models::disclosure::StartDisclosureResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_relyingParty = <crate::models::disclosure::Organization>::sse_decode(deserializer);
                let mut var_policy = <crate::models::disclosure::RequestPolicy>::sse_decode(deserializer);
                let mut var_requestedCards = <Vec<crate::models::disclosure::DisclosureCard>>::sse_decode(deserializer);
                let mut var_sharedDataWithRelyingPartyBefore = <bool>::sse_decode(deserializer);
                let mut var_sessionType = <crate::models::disclosure::DisclosureSessionType>::sse_decode(deserializer);
                let mut var_requestPurpose = <Vec<crate::models::card::LocalizedString>>::sse_decode(deserializer);
                let mut var_requestOriginBaseUrl = <String>::sse_decode(deserializer);
                let mut var_requestType = <crate::models::disclosure::DisclosureType>::sse_decode(deserializer);
                return crate::models::disclosure::StartDisclosureResult::Request {
                    relying_party: var_relyingParty,
                    policy: var_policy,
                    requested_cards: var_requestedCards,
                    shared_data_with_relying_party_before: var_sharedDataWithRelyingPartyBefore,
                    session_type: var_sessionType,
                    request_purpose: var_requestPurpose,
                    request_origin_base_url: var_requestOriginBaseUrl,
                    request_type: var_requestType,
                };
            }
            1 => {
                let mut var_relyingParty = <crate::models::disclosure::Organization>::sse_decode(deserializer);
                let mut var_missingAttributes =
                    <Vec<crate::models::disclosure::MissingAttribute>>::sse_decode(deserializer);
                let mut var_sharedDataWithRelyingPartyBefore = <bool>::sse_decode(deserializer);
                let mut var_sessionType = <crate::models::disclosure::DisclosureSessionType>::sse_decode(deserializer);
                let mut var_requestPurpose = <Vec<crate::models::card::LocalizedString>>::sse_decode(deserializer);
                let mut var_requestOriginBaseUrl = <String>::sse_decode(deserializer);
                return crate::models::disclosure::StartDisclosureResult::RequestAttributesMissing {
                    relying_party: var_relyingParty,
                    missing_attributes: var_missingAttributes,
                    shared_data_with_relying_party_before: var_sharedDataWithRelyingPartyBefore,
                    session_type: var_sessionType,
                    request_purpose: var_requestPurpose,
                    request_origin_base_url: var_requestOriginBaseUrl,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for crate::models::wallet_event::WalletEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_dateTime = <String>::sse_decode(deserializer);
                let mut var_relyingParty = <crate::models::disclosure::Organization>::sse_decode(deserializer);
                let mut var_purpose = <Vec<crate::models::card::LocalizedString>>::sse_decode(deserializer);
                let mut var_requestedCards =
                    <Option<Vec<crate::models::disclosure::DisclosureCard>>>::sse_decode(deserializer);
                let mut var_requestPolicy = <crate::models::disclosure::RequestPolicy>::sse_decode(deserializer);
                let mut var_status = <crate::models::disclosure::DisclosureStatus>::sse_decode(deserializer);
                let mut var_typ = <crate::models::disclosure::DisclosureType>::sse_decode(deserializer);
                return crate::models::wallet_event::WalletEvent::Disclosure {
                    date_time: var_dateTime,
                    relying_party: var_relyingParty,
                    purpose: var_purpose,
                    requested_cards: var_requestedCards,
                    request_policy: var_requestPolicy,
                    status: var_status,
                    typ: var_typ,
                };
            }
            1 => {
                let mut var_dateTime = <String>::sse_decode(deserializer);
                let mut var_card = <crate::models::card::Card>::sse_decode(deserializer);
                return crate::models::wallet_event::WalletEvent::Issuance {
                    date_time: var_dateTime,
                    card: var_card,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::instruction::WalletInstructionError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_attemptsLeftInRound = <u8>::sse_decode(deserializer);
                let mut var_isFinalRound = <bool>::sse_decode(deserializer);
                return crate::models::instruction::WalletInstructionError::IncorrectPin {
                    attempts_left_in_round: var_attemptsLeftInRound,
                    is_final_round: var_isFinalRound,
                };
            }
            1 => {
                let mut var_timeoutMillis = <u64>::sse_decode(deserializer);
                return crate::models::instruction::WalletInstructionError::Timeout {
                    timeout_millis: var_timeoutMillis,
                };
            }
            2 => {
                return crate::models::instruction::WalletInstructionError::Blocked;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::models::instruction::WalletInstructionResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::models::instruction::WalletInstructionResult::Ok;
            }
            1 => {
                let mut var_error = <crate::models::instruction::WalletInstructionError>::sse_decode(deserializer);
                return crate::models::instruction::WalletInstructionResult::InstructionError { error: var_error };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::disclosure::AcceptDisclosureResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::models::disclosure::AcceptDisclosureResult::Ok { return_url } => {
                [0.into_dart(), return_url.into_into_dart().into_dart()].into_dart()
            }
            crate::models::disclosure::AcceptDisclosureResult::InstructionError { error } => {
                [1.into_dart(), error.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::disclosure::AcceptDisclosureResult {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::disclosure::AcceptDisclosureResult>
    for crate::models::disclosure::AcceptDisclosureResult
{
    fn into_into_dart(self) -> crate::models::disclosure::AcceptDisclosureResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::card::Card {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.issuer.into_into_dart().into_dart(),
            self.persistence.into_into_dart().into_dart(),
            self.doc_type.into_into_dart().into_dart(),
            self.attributes.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::card::Card {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::card::Card> for crate::models::card::Card {
    fn into_into_dart(self) -> crate::models::card::Card {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::card::CardAttribute {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.key.into_into_dart().into_dart(),
            self.labels.into_into_dart().into_dart(),
            self.value.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::card::CardAttribute {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::card::CardAttribute> for crate::models::card::CardAttribute {
    fn into_into_dart(self) -> crate::models::card::CardAttribute {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::card::CardPersistence {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::models::card::CardPersistence::InMemory => [0.into_dart()].into_dart(),
            crate::models::card::CardPersistence::Stored { id } => {
                [1.into_dart(), id.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::card::CardPersistence {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::card::CardPersistence> for crate::models::card::CardPersistence {
    fn into_into_dart(self) -> crate::models::card::CardPersistence {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::card::CardValue {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::models::card::CardValue::String { value } => {
                [0.into_dart(), value.into_into_dart().into_dart()].into_dart()
            }
            crate::models::card::CardValue::Boolean { value } => {
                [1.into_dart(), value.into_into_dart().into_dart()].into_dart()
            }
            crate::models::card::CardValue::Date { value } => {
                [2.into_dart(), value.into_into_dart().into_dart()].into_dart()
            }
            crate::models::card::CardValue::Gender { value } => {
                [3.into_dart(), value.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::card::CardValue {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::card::CardValue> for crate::models::card::CardValue {
    fn into_into_dart(self) -> crate::models::card::CardValue {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::disclosure::DisclosureCard {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.issuer.into_into_dart().into_dart(),
            self.doc_type.into_into_dart().into_dart(),
            self.attributes.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::disclosure::DisclosureCard {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::disclosure::DisclosureCard>
    for crate::models::disclosure::DisclosureCard
{
    fn into_into_dart(self) -> crate::models::disclosure::DisclosureCard {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::disclosure::DisclosureSessionType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::SameDevice => 0.into_dart(),
            Self::CrossDevice => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::disclosure::DisclosureSessionType {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::disclosure::DisclosureSessionType>
    for crate::models::disclosure::DisclosureSessionType
{
    fn into_into_dart(self) -> crate::models::disclosure::DisclosureSessionType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::disclosure::DisclosureStatus {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Success => 0.into_dart(),
            Self::Cancelled => 1.into_dart(),
            Self::Error => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::disclosure::DisclosureStatus {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::disclosure::DisclosureStatus>
    for crate::models::disclosure::DisclosureStatus
{
    fn into_into_dart(self) -> crate::models::disclosure::DisclosureStatus {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::disclosure::DisclosureType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Login => 0.into_dart(),
            Self::Regular => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::disclosure::DisclosureType {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::disclosure::DisclosureType>
    for crate::models::disclosure::DisclosureType
{
    fn into_into_dart(self) -> crate::models::disclosure::DisclosureType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::config::FlutterConfiguration {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.inactive_lock_timeout.into_into_dart().into_dart(),
            self.background_lock_timeout.into_into_dart().into_dart(),
            self.version.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::config::FlutterConfiguration {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::config::FlutterConfiguration>
    for crate::models::config::FlutterConfiguration
{
    fn into_into_dart(self) -> crate::models::config::FlutterConfiguration {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::version_state::FlutterVersionState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::models::version_state::FlutterVersionState::Ok => [0.into_dart()].into_dart(),
            crate::models::version_state::FlutterVersionState::Notify => [1.into_dart()].into_dart(),
            crate::models::version_state::FlutterVersionState::Recommend => [2.into_dart()].into_dart(),
            crate::models::version_state::FlutterVersionState::Warn { expires_in_seconds } => {
                [3.into_dart(), expires_in_seconds.into_into_dart().into_dart()].into_dart()
            }
            crate::models::version_state::FlutterVersionState::Block => [4.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::version_state::FlutterVersionState {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::version_state::FlutterVersionState>
    for crate::models::version_state::FlutterVersionState
{
    fn into_into_dart(self) -> crate::models::version_state::FlutterVersionState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::card::GenderCardValue {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Unknown => 0.into_dart(),
            Self::Male => 1.into_dart(),
            Self::Female => 2.into_dart(),
            Self::NotApplicable => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::card::GenderCardValue {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::card::GenderCardValue> for crate::models::card::GenderCardValue {
    fn into_into_dart(self) -> crate::models::card::GenderCardValue {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::uri::IdentifyUriResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::PidIssuance => 0.into_dart(),
            Self::Disclosure => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::uri::IdentifyUriResult {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::uri::IdentifyUriResult>
    for crate::models::uri::IdentifyUriResult
{
    fn into_into_dart(self) -> crate::models::uri::IdentifyUriResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::disclosure::Image {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::models::disclosure::Image::Svg { xml } => {
                [0.into_dart(), xml.into_into_dart().into_dart()].into_dart()
            }
            crate::models::disclosure::Image::Png { base64 } => {
                [1.into_dart(), base64.into_into_dart().into_dart()].into_dart()
            }
            crate::models::disclosure::Image::Jpg { base64 } => {
                [2.into_dart(), base64.into_into_dart().into_dart()].into_dart()
            }
            crate::models::disclosure::Image::Asset { path } => {
                [3.into_dart(), path.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::disclosure::Image {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::disclosure::Image> for crate::models::disclosure::Image {
    fn into_into_dart(self) -> crate::models::disclosure::Image {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::card::LocalizedString {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.language.into_into_dart().into_dart(),
            self.value.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::card::LocalizedString {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::card::LocalizedString> for crate::models::card::LocalizedString {
    fn into_into_dart(self) -> crate::models::card::LocalizedString {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::disclosure::MissingAttribute {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.labels.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::disclosure::MissingAttribute {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::disclosure::MissingAttribute>
    for crate::models::disclosure::MissingAttribute
{
    fn into_into_dart(self) -> crate::models::disclosure::MissingAttribute {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::disclosure::Organization {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.legal_name.into_into_dart().into_dart(),
            self.display_name.into_into_dart().into_dart(),
            self.description.into_into_dart().into_dart(),
            self.image.into_into_dart().into_dart(),
            self.web_url.into_into_dart().into_dart(),
            self.privacy_policy_url.into_into_dart().into_dart(),
            self.kvk.into_into_dart().into_dart(),
            self.city.into_into_dart().into_dart(),
            self.category.into_into_dart().into_dart(),
            self.department.into_into_dart().into_dart(),
            self.country_code.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::disclosure::Organization {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::disclosure::Organization>
    for crate::models::disclosure::Organization
{
    fn into_into_dart(self) -> crate::models::disclosure::Organization {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::pin::PinValidationResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Ok => 0.into_dart(),
            Self::TooFewUniqueDigits => 1.into_dart(),
            Self::SequentialDigits => 2.into_dart(),
            Self::OtherIssue => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::pin::PinValidationResult {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::pin::PinValidationResult>
    for crate::models::pin::PinValidationResult
{
    fn into_into_dart(self) -> crate::models::pin::PinValidationResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::disclosure::RequestPolicy {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.data_storage_duration_in_minutes.into_into_dart().into_dart(),
            self.data_shared_with_third_parties.into_into_dart().into_dart(),
            self.data_deletion_possible.into_into_dart().into_dart(),
            self.policy_url.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::disclosure::RequestPolicy {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::disclosure::RequestPolicy>
    for crate::models::disclosure::RequestPolicy
{
    fn into_into_dart(self) -> crate::models::disclosure::RequestPolicy {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::disclosure::StartDisclosureResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::models::disclosure::StartDisclosureResult::Request {
                relying_party,
                policy,
                requested_cards,
                shared_data_with_relying_party_before,
                session_type,
                request_purpose,
                request_origin_base_url,
                request_type,
            } => [
                0.into_dart(),
                relying_party.into_into_dart().into_dart(),
                policy.into_into_dart().into_dart(),
                requested_cards.into_into_dart().into_dart(),
                shared_data_with_relying_party_before.into_into_dart().into_dart(),
                session_type.into_into_dart().into_dart(),
                request_purpose.into_into_dart().into_dart(),
                request_origin_base_url.into_into_dart().into_dart(),
                request_type.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::disclosure::StartDisclosureResult::RequestAttributesMissing {
                relying_party,
                missing_attributes,
                shared_data_with_relying_party_before,
                session_type,
                request_purpose,
                request_origin_base_url,
            } => [
                1.into_dart(),
                relying_party.into_into_dart().into_dart(),
                missing_attributes.into_into_dart().into_dart(),
                shared_data_with_relying_party_before.into_into_dart().into_dart(),
                session_type.into_into_dart().into_dart(),
                request_purpose.into_into_dart().into_dart(),
                request_origin_base_url.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::disclosure::StartDisclosureResult {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::disclosure::StartDisclosureResult>
    for crate::models::disclosure::StartDisclosureResult
{
    fn into_into_dart(self) -> crate::models::disclosure::StartDisclosureResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::wallet_event::WalletEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::models::wallet_event::WalletEvent::Disclosure {
                date_time,
                relying_party,
                purpose,
                requested_cards,
                request_policy,
                status,
                typ,
            } => [
                0.into_dart(),
                date_time.into_into_dart().into_dart(),
                relying_party.into_into_dart().into_dart(),
                purpose.into_into_dart().into_dart(),
                requested_cards.into_into_dart().into_dart(),
                request_policy.into_into_dart().into_dart(),
                status.into_into_dart().into_dart(),
                typ.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::wallet_event::WalletEvent::Issuance { date_time, card } => [
                1.into_dart(),
                date_time.into_into_dart().into_dart(),
                card.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::wallet_event::WalletEvent {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::wallet_event::WalletEvent>
    for crate::models::wallet_event::WalletEvent
{
    fn into_into_dart(self) -> crate::models::wallet_event::WalletEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::instruction::WalletInstructionError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::models::instruction::WalletInstructionError::IncorrectPin {
                attempts_left_in_round,
                is_final_round,
            } => [
                0.into_dart(),
                attempts_left_in_round.into_into_dart().into_dart(),
                is_final_round.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::instruction::WalletInstructionError::Timeout { timeout_millis } => {
                [1.into_dart(), timeout_millis.into_into_dart().into_dart()].into_dart()
            }
            crate::models::instruction::WalletInstructionError::Blocked => [2.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::instruction::WalletInstructionError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::instruction::WalletInstructionError>
    for crate::models::instruction::WalletInstructionError
{
    fn into_into_dart(self) -> crate::models::instruction::WalletInstructionError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::instruction::WalletInstructionResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::models::instruction::WalletInstructionResult::Ok => [0.into_dart()].into_dart(),
            crate::models::instruction::WalletInstructionResult::InstructionError { error } => {
                [1.into_dart(), error.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::instruction::WalletInstructionResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::instruction::WalletInstructionResult>
    for crate::models::instruction::WalletInstructionResult
{
    fn into_into_dart(self) -> crate::models::instruction::WalletInstructionResult {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for StreamSink<bool, flutter_rust_bridge::for_generated::DcoCodec> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<crate::models::config::FlutterConfiguration, flutter_rust_bridge::for_generated::DcoCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<crate::models::version_state::FlutterVersionState, flutter_rust_bridge::for_generated::DcoCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode for StreamSink<Vec<crate::models::card::Card>, flutter_rust_bridge::for_generated::DcoCodec> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<Vec<crate::models::wallet_event::WalletEvent>, flutter_rust_bridge::for_generated::DcoCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::models::disclosure::AcceptDisclosureResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::disclosure::AcceptDisclosureResult::Ok { return_url } => {
                <i32>::sse_encode(0, serializer);
                <Option<String>>::sse_encode(return_url, serializer);
            }
            crate::models::disclosure::AcceptDisclosureResult::InstructionError { error } => {
                <i32>::sse_encode(1, serializer);
                <crate::models::instruction::WalletInstructionError>::sse_encode(error, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::models::card::Card {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::disclosure::Organization>::sse_encode(self.issuer, serializer);
        <crate::models::card::CardPersistence>::sse_encode(self.persistence, serializer);
        <String>::sse_encode(self.doc_type, serializer);
        <Vec<crate::models::card::CardAttribute>>::sse_encode(self.attributes, serializer);
    }
}

impl SseEncode for crate::models::card::CardAttribute {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.key, serializer);
        <Vec<crate::models::card::LocalizedString>>::sse_encode(self.labels, serializer);
        <crate::models::card::CardValue>::sse_encode(self.value, serializer);
    }
}

impl SseEncode for crate::models::card::CardPersistence {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::card::CardPersistence::InMemory => {
                <i32>::sse_encode(0, serializer);
            }
            crate::models::card::CardPersistence::Stored { id } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(id, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::card::CardValue {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::card::CardValue::String { value } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(value, serializer);
            }
            crate::models::card::CardValue::Boolean { value } => {
                <i32>::sse_encode(1, serializer);
                <bool>::sse_encode(value, serializer);
            }
            crate::models::card::CardValue::Date { value } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(value, serializer);
            }
            crate::models::card::CardValue::Gender { value } => {
                <i32>::sse_encode(3, serializer);
                <crate::models::card::GenderCardValue>::sse_encode(value, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::disclosure::DisclosureCard {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::disclosure::Organization>::sse_encode(self.issuer, serializer);
        <String>::sse_encode(self.doc_type, serializer);
        <Vec<crate::models::card::CardAttribute>>::sse_encode(self.attributes, serializer);
    }
}

impl SseEncode for crate::models::disclosure::DisclosureSessionType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::disclosure::DisclosureSessionType::SameDevice => 0,
                crate::models::disclosure::DisclosureSessionType::CrossDevice => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::disclosure::DisclosureStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::disclosure::DisclosureStatus::Success => 0,
                crate::models::disclosure::DisclosureStatus::Cancelled => 1,
                crate::models::disclosure::DisclosureStatus::Error => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::disclosure::DisclosureType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::disclosure::DisclosureType::Login => 0,
                crate::models::disclosure::DisclosureType::Regular => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::config::FlutterConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u16>::sse_encode(self.inactive_lock_timeout, serializer);
        <u16>::sse_encode(self.background_lock_timeout, serializer);
        <u64>::sse_encode(self.version, serializer);
    }
}

impl SseEncode for crate::models::version_state::FlutterVersionState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::version_state::FlutterVersionState::Ok => {
                <i32>::sse_encode(0, serializer);
            }
            crate::models::version_state::FlutterVersionState::Notify => {
                <i32>::sse_encode(1, serializer);
            }
            crate::models::version_state::FlutterVersionState::Recommend => {
                <i32>::sse_encode(2, serializer);
            }
            crate::models::version_state::FlutterVersionState::Warn { expires_in_seconds } => {
                <i32>::sse_encode(3, serializer);
                <u64>::sse_encode(expires_in_seconds, serializer);
            }
            crate::models::version_state::FlutterVersionState::Block => {
                <i32>::sse_encode(4, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::card::GenderCardValue {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::card::GenderCardValue::Unknown => 0,
                crate::models::card::GenderCardValue::Male => 1,
                crate::models::card::GenderCardValue::Female => 2,
                crate::models::card::GenderCardValue::NotApplicable => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::models::uri::IdentifyUriResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::uri::IdentifyUriResult::PidIssuance => 0,
                crate::models::uri::IdentifyUriResult::Disclosure => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::disclosure::Image {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::disclosure::Image::Svg { xml } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(xml, serializer);
            }
            crate::models::disclosure::Image::Png { base64 } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(base64, serializer);
            }
            crate::models::disclosure::Image::Jpg { base64 } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(base64, serializer);
            }
            crate::models::disclosure::Image::Asset { path } => {
                <i32>::sse_encode(3, serializer);
                <String>::sse_encode(path, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for Vec<crate::models::card::Card> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::card::Card>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::card::CardAttribute> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::card::CardAttribute>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::disclosure::DisclosureCard> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::disclosure::DisclosureCard>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::card::LocalizedString> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::card::LocalizedString>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::disclosure::MissingAttribute> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::disclosure::MissingAttribute>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::wallet_event::WalletEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::wallet_event::WalletEvent>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::models::card::LocalizedString {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.language, serializer);
        <String>::sse_encode(self.value, serializer);
    }
}

impl SseEncode for crate::models::disclosure::MissingAttribute {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::models::card::LocalizedString>>::sse_encode(self.labels, serializer);
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::disclosure::Image> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::disclosure::Image>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::models::disclosure::DisclosureCard>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::models::disclosure::DisclosureCard>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::models::card::LocalizedString>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::models::card::LocalizedString>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::models::disclosure::Organization {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::models::card::LocalizedString>>::sse_encode(self.legal_name, serializer);
        <Vec<crate::models::card::LocalizedString>>::sse_encode(self.display_name, serializer);
        <Vec<crate::models::card::LocalizedString>>::sse_encode(self.description, serializer);
        <Option<crate::models::disclosure::Image>>::sse_encode(self.image, serializer);
        <Option<String>>::sse_encode(self.web_url, serializer);
        <Option<String>>::sse_encode(self.privacy_policy_url, serializer);
        <Option<String>>::sse_encode(self.kvk, serializer);
        <Option<Vec<crate::models::card::LocalizedString>>>::sse_encode(self.city, serializer);
        <Vec<crate::models::card::LocalizedString>>::sse_encode(self.category, serializer);
        <Option<Vec<crate::models::card::LocalizedString>>>::sse_encode(self.department, serializer);
        <Option<String>>::sse_encode(self.country_code, serializer);
    }
}

impl SseEncode for crate::models::pin::PinValidationResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::pin::PinValidationResult::Ok => 0,
                crate::models::pin::PinValidationResult::TooFewUniqueDigits => 1,
                crate::models::pin::PinValidationResult::SequentialDigits => 2,
                crate::models::pin::PinValidationResult::OtherIssue => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::models::disclosure::RequestPolicy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.data_storage_duration_in_minutes, serializer);
        <bool>::sse_encode(self.data_shared_with_third_parties, serializer);
        <bool>::sse_encode(self.data_deletion_possible, serializer);
        <String>::sse_encode(self.policy_url, serializer);
    }
}

impl SseEncode for crate::models::disclosure::StartDisclosureResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::disclosure::StartDisclosureResult::Request {
                relying_party,
                policy,
                requested_cards,
                shared_data_with_relying_party_before,
                session_type,
                request_purpose,
                request_origin_base_url,
                request_type,
            } => {
                <i32>::sse_encode(0, serializer);
                <crate::models::disclosure::Organization>::sse_encode(relying_party, serializer);
                <crate::models::disclosure::RequestPolicy>::sse_encode(policy, serializer);
                <Vec<crate::models::disclosure::DisclosureCard>>::sse_encode(requested_cards, serializer);
                <bool>::sse_encode(shared_data_with_relying_party_before, serializer);
                <crate::models::disclosure::DisclosureSessionType>::sse_encode(session_type, serializer);
                <Vec<crate::models::card::LocalizedString>>::sse_encode(request_purpose, serializer);
                <String>::sse_encode(request_origin_base_url, serializer);
                <crate::models::disclosure::DisclosureType>::sse_encode(request_type, serializer);
            }
            crate::models::disclosure::StartDisclosureResult::RequestAttributesMissing {
                relying_party,
                missing_attributes,
                shared_data_with_relying_party_before,
                session_type,
                request_purpose,
                request_origin_base_url,
            } => {
                <i32>::sse_encode(1, serializer);
                <crate::models::disclosure::Organization>::sse_encode(relying_party, serializer);
                <Vec<crate::models::disclosure::MissingAttribute>>::sse_encode(missing_attributes, serializer);
                <bool>::sse_encode(shared_data_with_relying_party_before, serializer);
                <crate::models::disclosure::DisclosureSessionType>::sse_encode(session_type, serializer);
                <Vec<crate::models::card::LocalizedString>>::sse_encode(request_purpose, serializer);
                <String>::sse_encode(request_origin_base_url, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::models::wallet_event::WalletEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::wallet_event::WalletEvent::Disclosure {
                date_time,
                relying_party,
                purpose,
                requested_cards,
                request_policy,
                status,
                typ,
            } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(date_time, serializer);
                <crate::models::disclosure::Organization>::sse_encode(relying_party, serializer);
                <Vec<crate::models::card::LocalizedString>>::sse_encode(purpose, serializer);
                <Option<Vec<crate::models::disclosure::DisclosureCard>>>::sse_encode(requested_cards, serializer);
                <crate::models::disclosure::RequestPolicy>::sse_encode(request_policy, serializer);
                <crate::models::disclosure::DisclosureStatus>::sse_encode(status, serializer);
                <crate::models::disclosure::DisclosureType>::sse_encode(typ, serializer);
            }
            crate::models::wallet_event::WalletEvent::Issuance { date_time, card } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(date_time, serializer);
                <crate::models::card::Card>::sse_encode(card, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::instruction::WalletInstructionError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::instruction::WalletInstructionError::IncorrectPin {
                attempts_left_in_round,
                is_final_round,
            } => {
                <i32>::sse_encode(0, serializer);
                <u8>::sse_encode(attempts_left_in_round, serializer);
                <bool>::sse_encode(is_final_round, serializer);
            }
            crate::models::instruction::WalletInstructionError::Timeout { timeout_millis } => {
                <i32>::sse_encode(1, serializer);
                <u64>::sse_encode(timeout_millis, serializer);
            }
            crate::models::instruction::WalletInstructionError::Blocked => {
                <i32>::sse_encode(2, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::models::instruction::WalletInstructionResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::instruction::WalletInstructionResult::Ok => {
                <i32>::sse_encode(0, serializer);
            }
            crate::models::instruction::WalletInstructionResult::InstructionError { error } => {
                <i32>::sse_encode(1, serializer);
                <crate::models::instruction::WalletInstructionError>::sse_encode(error, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.7.1.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    // Section: dart2rust

    impl CstDecode<flutter_rust_bridge::for_generated::anyhow::Error> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> flutter_rust_bridge::for_generated::anyhow::Error {
            unimplemented!()
        }
    }
    impl CstDecode<StreamSink<bool, flutter_rust_bridge::for_generated::DcoCodec>> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> StreamSink<bool, flutter_rust_bridge::for_generated::DcoCodec> {
            let raw: String = self.cst_decode();
            StreamSink::deserialize(raw)
        }
    }
    impl
        CstDecode<StreamSink<crate::models::config::FlutterConfiguration, flutter_rust_bridge::for_generated::DcoCodec>>
        for *mut wire_cst_list_prim_u_8_strict
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> StreamSink<crate::models::config::FlutterConfiguration, flutter_rust_bridge::for_generated::DcoCodec>
        {
            let raw: String = self.cst_decode();
            StreamSink::deserialize(raw)
        }
    }
    impl
        CstDecode<
            StreamSink<crate::models::version_state::FlutterVersionState, flutter_rust_bridge::for_generated::DcoCodec>,
        > for *mut wire_cst_list_prim_u_8_strict
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> StreamSink<crate::models::version_state::FlutterVersionState, flutter_rust_bridge::for_generated::DcoCodec>
        {
            let raw: String = self.cst_decode();
            StreamSink::deserialize(raw)
        }
    }
    impl CstDecode<StreamSink<Vec<crate::models::card::Card>, flutter_rust_bridge::for_generated::DcoCodec>>
        for *mut wire_cst_list_prim_u_8_strict
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> StreamSink<Vec<crate::models::card::Card>, flutter_rust_bridge::for_generated::DcoCodec> {
            let raw: String = self.cst_decode();
            StreamSink::deserialize(raw)
        }
    }
    impl
        CstDecode<
            StreamSink<Vec<crate::models::wallet_event::WalletEvent>, flutter_rust_bridge::for_generated::DcoCodec>,
        > for *mut wire_cst_list_prim_u_8_strict
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> StreamSink<Vec<crate::models::wallet_event::WalletEvent>, flutter_rust_bridge::for_generated::DcoCodec>
        {
            let raw: String = self.cst_decode();
            StreamSink::deserialize(raw)
        }
    }
    impl CstDecode<String> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            let vec: Vec<u8> = self.cst_decode();
            String::from_utf8(vec).unwrap()
        }
    }
    impl CstDecode<crate::models::disclosure::AcceptDisclosureResult> for wire_cst_accept_disclosure_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::disclosure::AcceptDisclosureResult {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Ok };
                    crate::models::disclosure::AcceptDisclosureResult::Ok {
                        return_url: ans.return_url.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.InstructionError };
                    crate::models::disclosure::AcceptDisclosureResult::InstructionError {
                        error: ans.error.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::models::card::Card> for *mut wire_cst_card {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::card::Card {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::models::card::Card>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::models::disclosure::Image> for *mut wire_cst_image {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::disclosure::Image {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::models::disclosure::Image>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::models::disclosure::Organization> for *mut wire_cst_organization {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::disclosure::Organization {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::models::disclosure::Organization>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::models::disclosure::RequestPolicy> for *mut wire_cst_request_policy {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::disclosure::RequestPolicy {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::models::disclosure::RequestPolicy>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<u64> for *mut u64 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u64 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<crate::models::instruction::WalletInstructionError> for *mut wire_cst_wallet_instruction_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::instruction::WalletInstructionError {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::models::instruction::WalletInstructionError>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::models::card::Card> for wire_cst_card {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::card::Card {
            crate::models::card::Card {
                issuer: self.issuer.cst_decode(),
                persistence: self.persistence.cst_decode(),
                doc_type: self.doc_type.cst_decode(),
                attributes: self.attributes.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::card::CardAttribute> for wire_cst_card_attribute {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::card::CardAttribute {
            crate::models::card::CardAttribute {
                key: self.key.cst_decode(),
                labels: self.labels.cst_decode(),
                value: self.value.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::card::CardPersistence> for wire_cst_card_persistence {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::card::CardPersistence {
            match self.tag {
                0 => crate::models::card::CardPersistence::InMemory,
                1 => {
                    let ans = unsafe { self.kind.Stored };
                    crate::models::card::CardPersistence::Stored {
                        id: ans.id.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::models::card::CardValue> for wire_cst_card_value {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::card::CardValue {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.String };
                    crate::models::card::CardValue::String {
                        value: ans.value.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.Boolean };
                    crate::models::card::CardValue::Boolean {
                        value: ans.value.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.Date };
                    crate::models::card::CardValue::Date {
                        value: ans.value.cst_decode(),
                    }
                }
                3 => {
                    let ans = unsafe { self.kind.Gender };
                    crate::models::card::CardValue::Gender {
                        value: ans.value.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::models::disclosure::DisclosureCard> for wire_cst_disclosure_card {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::disclosure::DisclosureCard {
            crate::models::disclosure::DisclosureCard {
                issuer: self.issuer.cst_decode(),
                doc_type: self.doc_type.cst_decode(),
                attributes: self.attributes.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::config::FlutterConfiguration> for wire_cst_flutter_configuration {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::config::FlutterConfiguration {
            crate::models::config::FlutterConfiguration {
                inactive_lock_timeout: self.inactive_lock_timeout.cst_decode(),
                background_lock_timeout: self.background_lock_timeout.cst_decode(),
                version: self.version.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::version_state::FlutterVersionState> for wire_cst_flutter_version_state {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::version_state::FlutterVersionState {
            match self.tag {
                0 => crate::models::version_state::FlutterVersionState::Ok,
                1 => crate::models::version_state::FlutterVersionState::Notify,
                2 => crate::models::version_state::FlutterVersionState::Recommend,
                3 => {
                    let ans = unsafe { self.kind.Warn };
                    crate::models::version_state::FlutterVersionState::Warn {
                        expires_in_seconds: ans.expires_in_seconds.cst_decode(),
                    }
                }
                4 => crate::models::version_state::FlutterVersionState::Block,
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::models::disclosure::Image> for wire_cst_image {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::disclosure::Image {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Svg };
                    crate::models::disclosure::Image::Svg {
                        xml: ans.xml.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.Png };
                    crate::models::disclosure::Image::Png {
                        base64: ans.base64.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.Jpg };
                    crate::models::disclosure::Image::Jpg {
                        base64: ans.base64.cst_decode(),
                    }
                }
                3 => {
                    let ans = unsafe { self.kind.Asset };
                    crate::models::disclosure::Image::Asset {
                        path: ans.path.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<Vec<crate::models::card::Card>> for *mut wire_cst_list_card {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::card::Card> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::models::card::CardAttribute>> for *mut wire_cst_list_card_attribute {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::card::CardAttribute> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::models::disclosure::DisclosureCard>> for *mut wire_cst_list_disclosure_card {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::disclosure::DisclosureCard> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::models::card::LocalizedString>> for *mut wire_cst_list_localized_string {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::card::LocalizedString> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::models::disclosure::MissingAttribute>> for *mut wire_cst_list_missing_attribute {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::disclosure::MissingAttribute> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<crate::models::wallet_event::WalletEvent>> for *mut wire_cst_list_wallet_event {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::models::wallet_event::WalletEvent> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<crate::models::card::LocalizedString> for wire_cst_localized_string {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::card::LocalizedString {
            crate::models::card::LocalizedString {
                language: self.language.cst_decode(),
                value: self.value.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::disclosure::MissingAttribute> for wire_cst_missing_attribute {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::disclosure::MissingAttribute {
            crate::models::disclosure::MissingAttribute {
                labels: self.labels.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::disclosure::Organization> for wire_cst_organization {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::disclosure::Organization {
            crate::models::disclosure::Organization {
                legal_name: self.legal_name.cst_decode(),
                display_name: self.display_name.cst_decode(),
                description: self.description.cst_decode(),
                image: self.image.cst_decode(),
                web_url: self.web_url.cst_decode(),
                privacy_policy_url: self.privacy_policy_url.cst_decode(),
                kvk: self.kvk.cst_decode(),
                city: self.city.cst_decode(),
                category: self.category.cst_decode(),
                department: self.department.cst_decode(),
                country_code: self.country_code.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::disclosure::RequestPolicy> for wire_cst_request_policy {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::disclosure::RequestPolicy {
            crate::models::disclosure::RequestPolicy {
                data_storage_duration_in_minutes: self.data_storage_duration_in_minutes.cst_decode(),
                data_shared_with_third_parties: self.data_shared_with_third_parties.cst_decode(),
                data_deletion_possible: self.data_deletion_possible.cst_decode(),
                policy_url: self.policy_url.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::models::disclosure::StartDisclosureResult> for wire_cst_start_disclosure_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::disclosure::StartDisclosureResult {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Request };
                    crate::models::disclosure::StartDisclosureResult::Request {
                        relying_party: ans.relying_party.cst_decode(),
                        policy: ans.policy.cst_decode(),
                        requested_cards: ans.requested_cards.cst_decode(),
                        shared_data_with_relying_party_before: ans.shared_data_with_relying_party_before.cst_decode(),
                        session_type: ans.session_type.cst_decode(),
                        request_purpose: ans.request_purpose.cst_decode(),
                        request_origin_base_url: ans.request_origin_base_url.cst_decode(),
                        request_type: ans.request_type.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.RequestAttributesMissing };
                    crate::models::disclosure::StartDisclosureResult::RequestAttributesMissing {
                        relying_party: ans.relying_party.cst_decode(),
                        missing_attributes: ans.missing_attributes.cst_decode(),
                        shared_data_with_relying_party_before: ans.shared_data_with_relying_party_before.cst_decode(),
                        session_type: ans.session_type.cst_decode(),
                        request_purpose: ans.request_purpose.cst_decode(),
                        request_origin_base_url: ans.request_origin_base_url.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::models::wallet_event::WalletEvent> for wire_cst_wallet_event {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::wallet_event::WalletEvent {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Disclosure };
                    crate::models::wallet_event::WalletEvent::Disclosure {
                        date_time: ans.date_time.cst_decode(),
                        relying_party: ans.relying_party.cst_decode(),
                        purpose: ans.purpose.cst_decode(),
                        requested_cards: ans.requested_cards.cst_decode(),
                        request_policy: ans.request_policy.cst_decode(),
                        status: ans.status.cst_decode(),
                        typ: ans.typ.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.Issuance };
                    crate::models::wallet_event::WalletEvent::Issuance {
                        date_time: ans.date_time.cst_decode(),
                        card: ans.card.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::models::instruction::WalletInstructionError> for wire_cst_wallet_instruction_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::instruction::WalletInstructionError {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.IncorrectPin };
                    crate::models::instruction::WalletInstructionError::IncorrectPin {
                        attempts_left_in_round: ans.attempts_left_in_round.cst_decode(),
                        is_final_round: ans.is_final_round.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.Timeout };
                    crate::models::instruction::WalletInstructionError::Timeout {
                        timeout_millis: ans.timeout_millis.cst_decode(),
                    }
                }
                2 => crate::models::instruction::WalletInstructionError::Blocked,
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::models::instruction::WalletInstructionResult> for wire_cst_wallet_instruction_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::models::instruction::WalletInstructionResult {
            match self.tag {
                0 => crate::models::instruction::WalletInstructionResult::Ok,
                1 => {
                    let ans = unsafe { self.kind.InstructionError };
                    crate::models::instruction::WalletInstructionResult::InstructionError {
                        error: ans.error.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl NewWithNullPtr for wire_cst_accept_disclosure_result {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: AcceptDisclosureResultKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_accept_disclosure_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_card {
        fn new_with_null_ptr() -> Self {
            Self {
                issuer: Default::default(),
                persistence: Default::default(),
                doc_type: core::ptr::null_mut(),
                attributes: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_card {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_card_attribute {
        fn new_with_null_ptr() -> Self {
            Self {
                key: core::ptr::null_mut(),
                labels: core::ptr::null_mut(),
                value: Default::default(),
            }
        }
    }
    impl Default for wire_cst_card_attribute {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_card_persistence {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: CardPersistenceKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_card_persistence {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_card_value {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: CardValueKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_card_value {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_disclosure_card {
        fn new_with_null_ptr() -> Self {
            Self {
                issuer: Default::default(),
                doc_type: core::ptr::null_mut(),
                attributes: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_disclosure_card {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_flutter_configuration {
        fn new_with_null_ptr() -> Self {
            Self {
                inactive_lock_timeout: Default::default(),
                background_lock_timeout: Default::default(),
                version: Default::default(),
            }
        }
    }
    impl Default for wire_cst_flutter_configuration {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_flutter_version_state {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: FlutterVersionStateKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_flutter_version_state {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_image {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: ImageKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_image {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_localized_string {
        fn new_with_null_ptr() -> Self {
            Self {
                language: core::ptr::null_mut(),
                value: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_localized_string {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_missing_attribute {
        fn new_with_null_ptr() -> Self {
            Self {
                labels: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_missing_attribute {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_organization {
        fn new_with_null_ptr() -> Self {
            Self {
                legal_name: core::ptr::null_mut(),
                display_name: core::ptr::null_mut(),
                description: core::ptr::null_mut(),
                image: core::ptr::null_mut(),
                web_url: core::ptr::null_mut(),
                privacy_policy_url: core::ptr::null_mut(),
                kvk: core::ptr::null_mut(),
                city: core::ptr::null_mut(),
                category: core::ptr::null_mut(),
                department: core::ptr::null_mut(),
                country_code: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_organization {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_request_policy {
        fn new_with_null_ptr() -> Self {
            Self {
                data_storage_duration_in_minutes: core::ptr::null_mut(),
                data_shared_with_third_parties: Default::default(),
                data_deletion_possible: Default::default(),
                policy_url: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_request_policy {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_start_disclosure_result {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: StartDisclosureResultKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_start_disclosure_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_wallet_event {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: WalletEventKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_wallet_event {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_wallet_instruction_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: WalletInstructionErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_wallet_instruction_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_wallet_instruction_result {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: WalletInstructionResultKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_wallet_instruction_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__accept_disclosure(
        port_: i64,
        pin: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__full__accept_disclosure_impl(port_, pin)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__accept_pid_issuance(
        port_: i64,
        pin: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__full__accept_pid_issuance_impl(port_, pin)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__cancel_disclosure(port_: i64) {
        wire__crate__api__full__cancel_disclosure_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__cancel_pid_issuance(port_: i64) {
        wire__crate__api__full__cancel_pid_issuance_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__change_pin(
        port_: i64,
        old_pin: *mut wire_cst_list_prim_u_8_strict,
        new_pin: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__full__change_pin_impl(port_, old_pin, new_pin)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__check_pin(
        port_: i64,
        pin: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__full__check_pin_impl(port_, pin)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__clear_cards_stream(port_: i64) {
        wire__crate__api__full__clear_cards_stream_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__clear_configuration_stream(port_: i64) {
        wire__crate__api__full__clear_configuration_stream_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__clear_lock_stream(port_: i64) {
        wire__crate__api__full__clear_lock_stream_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__clear_recent_history_stream(port_: i64) {
        wire__crate__api__full__clear_recent_history_stream_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__clear_version_state_stream(port_: i64) {
        wire__crate__api__full__clear_version_state_stream_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__continue_change_pin(
        port_: i64,
        pin: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__full__continue_change_pin_impl(port_, pin)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__continue_pid_issuance(
        port_: i64,
        uri: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__full__continue_pid_issuance_impl(port_, uri)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__create_pid_issuance_redirect_uri(port_: i64) {
        wire__crate__api__full__create_pid_issuance_redirect_uri_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__get_history(port_: i64) {
        wire__crate__api__full__get_history_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__get_history_for_card(
        port_: i64,
        doc_type: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__full__get_history_for_card_impl(port_, doc_type)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__get_version_string(port_: i64) {
        wire__crate__api__full__get_version_string_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__has_active_disclosure_session(port_: i64) {
        wire__crate__api__full__has_active_disclosure_session_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__has_active_pid_issuance_session(port_: i64) {
        wire__crate__api__full__has_active_pid_issuance_session_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__has_registration(port_: i64) {
        wire__crate__api__full__has_registration_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__identify_uri(
        port_: i64,
        uri: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__full__identify_uri_impl(port_, uri)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__init(port_: i64) {
        wire__crate__api__full__init_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__is_biometric_unlock_enabled(port_: i64) {
        wire__crate__api__full__is_biometric_unlock_enabled_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__is_initialized(port_: i64) {
        wire__crate__api__full__is_initialized_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__is_valid_pin(
        port_: i64,
        pin: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__full__is_valid_pin_impl(port_, pin)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__lock_wallet(port_: i64) {
        wire__crate__api__full__lock_wallet_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__register(
        port_: i64,
        pin: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__full__register_impl(port_, pin)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__reset_wallet(port_: i64) {
        wire__crate__api__full__reset_wallet_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__set_biometric_unlock(port_: i64, enable: bool) {
        wire__crate__api__full__set_biometric_unlock_impl(port_, enable)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__set_cards_stream(
        port_: i64,
        sink: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__full__set_cards_stream_impl(port_, sink)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__set_configuration_stream(
        port_: i64,
        sink: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__full__set_configuration_stream_impl(port_, sink)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__set_lock_stream(
        port_: i64,
        sink: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__full__set_lock_stream_impl(port_, sink)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__set_recent_history_stream(
        port_: i64,
        sink: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__full__set_recent_history_stream_impl(port_, sink)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__set_version_state_stream(
        port_: i64,
        sink: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__full__set_version_state_stream_impl(port_, sink)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__start_disclosure(
        port_: i64,
        uri: *mut wire_cst_list_prim_u_8_strict,
        is_qr_code: bool,
    ) {
        wire__crate__api__full__start_disclosure_impl(port_, uri, is_qr_code)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__unlock_wallet(
        port_: i64,
        pin: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__full__unlock_wallet_impl(port_, pin)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_wire__crate__api__full__unlock_wallet_with_biometrics(port_: i64) {
        wire__crate__api__full__unlock_wallet_with_biometrics_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_cst_new_box_autoadd_card() -> *mut wire_cst_card {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_card::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_cst_new_box_autoadd_image() -> *mut wire_cst_image {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_image::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_cst_new_box_autoadd_organization() -> *mut wire_cst_organization {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_organization::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_cst_new_box_autoadd_request_policy() -> *mut wire_cst_request_policy {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_request_policy::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_cst_new_box_autoadd_u_64(value: u64) -> *mut u64 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_cst_new_box_autoadd_wallet_instruction_error(
    ) -> *mut wire_cst_wallet_instruction_error {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_wallet_instruction_error::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_cst_new_list_card(len: i32) -> *mut wire_cst_list_card {
        let wrap = wire_cst_list_card {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(<wire_cst_card>::new_with_null_ptr(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_cst_new_list_card_attribute(len: i32) -> *mut wire_cst_list_card_attribute {
        let wrap = wire_cst_list_card_attribute {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_card_attribute>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_cst_new_list_disclosure_card(len: i32) -> *mut wire_cst_list_disclosure_card {
        let wrap = wire_cst_list_disclosure_card {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_disclosure_card>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_cst_new_list_localized_string(
        len: i32,
    ) -> *mut wire_cst_list_localized_string {
        let wrap = wire_cst_list_localized_string {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_localized_string>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_cst_new_list_missing_attribute(
        len: i32,
    ) -> *mut wire_cst_list_missing_attribute {
        let wrap = wire_cst_list_missing_attribute {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_missing_attribute>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_cst_new_list_prim_u_8_strict(len: i32) -> *mut wire_cst_list_prim_u_8_strict {
        let ans = wire_cst_list_prim_u_8_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_wallet_core_cst_new_list_wallet_event(len: i32) -> *mut wire_cst_list_wallet_event {
        let wrap = wire_cst_list_wallet_event {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_wallet_event>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_accept_disclosure_result {
        tag: i32,
        kind: AcceptDisclosureResultKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union AcceptDisclosureResultKind {
        Ok: wire_cst_AcceptDisclosureResult_Ok,
        InstructionError: wire_cst_AcceptDisclosureResult_InstructionError,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_AcceptDisclosureResult_Ok {
        return_url: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_AcceptDisclosureResult_InstructionError {
        error: *mut wire_cst_wallet_instruction_error,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_card {
        issuer: wire_cst_organization,
        persistence: wire_cst_card_persistence,
        doc_type: *mut wire_cst_list_prim_u_8_strict,
        attributes: *mut wire_cst_list_card_attribute,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_card_attribute {
        key: *mut wire_cst_list_prim_u_8_strict,
        labels: *mut wire_cst_list_localized_string,
        value: wire_cst_card_value,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_card_persistence {
        tag: i32,
        kind: CardPersistenceKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union CardPersistenceKind {
        Stored: wire_cst_CardPersistence_Stored,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CardPersistence_Stored {
        id: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_card_value {
        tag: i32,
        kind: CardValueKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union CardValueKind {
        String: wire_cst_CardValue_String,
        Boolean: wire_cst_CardValue_Boolean,
        Date: wire_cst_CardValue_Date,
        Gender: wire_cst_CardValue_Gender,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CardValue_String {
        value: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CardValue_Boolean {
        value: bool,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CardValue_Date {
        value: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_CardValue_Gender {
        value: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_disclosure_card {
        issuer: wire_cst_organization,
        doc_type: *mut wire_cst_list_prim_u_8_strict,
        attributes: *mut wire_cst_list_card_attribute,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_flutter_configuration {
        inactive_lock_timeout: u16,
        background_lock_timeout: u16,
        version: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_flutter_version_state {
        tag: i32,
        kind: FlutterVersionStateKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union FlutterVersionStateKind {
        Warn: wire_cst_FlutterVersionState_Warn,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_FlutterVersionState_Warn {
        expires_in_seconds: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_image {
        tag: i32,
        kind: ImageKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union ImageKind {
        Svg: wire_cst_Image_Svg,
        Png: wire_cst_Image_Png,
        Jpg: wire_cst_Image_Jpg,
        Asset: wire_cst_Image_Asset,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Image_Svg {
        xml: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Image_Png {
        base64: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Image_Jpg {
        base64: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Image_Asset {
        path: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_card {
        ptr: *mut wire_cst_card,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_card_attribute {
        ptr: *mut wire_cst_card_attribute,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_disclosure_card {
        ptr: *mut wire_cst_disclosure_card,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_localized_string {
        ptr: *mut wire_cst_localized_string,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_missing_attribute {
        ptr: *mut wire_cst_missing_attribute,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_strict {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_wallet_event {
        ptr: *mut wire_cst_wallet_event,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_localized_string {
        language: *mut wire_cst_list_prim_u_8_strict,
        value: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_missing_attribute {
        labels: *mut wire_cst_list_localized_string,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_organization {
        legal_name: *mut wire_cst_list_localized_string,
        display_name: *mut wire_cst_list_localized_string,
        description: *mut wire_cst_list_localized_string,
        image: *mut wire_cst_image,
        web_url: *mut wire_cst_list_prim_u_8_strict,
        privacy_policy_url: *mut wire_cst_list_prim_u_8_strict,
        kvk: *mut wire_cst_list_prim_u_8_strict,
        city: *mut wire_cst_list_localized_string,
        category: *mut wire_cst_list_localized_string,
        department: *mut wire_cst_list_localized_string,
        country_code: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_request_policy {
        data_storage_duration_in_minutes: *mut u64,
        data_shared_with_third_parties: bool,
        data_deletion_possible: bool,
        policy_url: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_start_disclosure_result {
        tag: i32,
        kind: StartDisclosureResultKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union StartDisclosureResultKind {
        Request: wire_cst_StartDisclosureResult_Request,
        RequestAttributesMissing: wire_cst_StartDisclosureResult_RequestAttributesMissing,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_StartDisclosureResult_Request {
        relying_party: *mut wire_cst_organization,
        policy: *mut wire_cst_request_policy,
        requested_cards: *mut wire_cst_list_disclosure_card,
        shared_data_with_relying_party_before: bool,
        session_type: i32,
        request_purpose: *mut wire_cst_list_localized_string,
        request_origin_base_url: *mut wire_cst_list_prim_u_8_strict,
        request_type: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_StartDisclosureResult_RequestAttributesMissing {
        relying_party: *mut wire_cst_organization,
        missing_attributes: *mut wire_cst_list_missing_attribute,
        shared_data_with_relying_party_before: bool,
        session_type: i32,
        request_purpose: *mut wire_cst_list_localized_string,
        request_origin_base_url: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_wallet_event {
        tag: i32,
        kind: WalletEventKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union WalletEventKind {
        Disclosure: wire_cst_WalletEvent_Disclosure,
        Issuance: wire_cst_WalletEvent_Issuance,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_WalletEvent_Disclosure {
        date_time: *mut wire_cst_list_prim_u_8_strict,
        relying_party: *mut wire_cst_organization,
        purpose: *mut wire_cst_list_localized_string,
        requested_cards: *mut wire_cst_list_disclosure_card,
        request_policy: *mut wire_cst_request_policy,
        status: i32,
        typ: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_WalletEvent_Issuance {
        date_time: *mut wire_cst_list_prim_u_8_strict,
        card: *mut wire_cst_card,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_wallet_instruction_error {
        tag: i32,
        kind: WalletInstructionErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union WalletInstructionErrorKind {
        IncorrectPin: wire_cst_WalletInstructionError_IncorrectPin,
        Timeout: wire_cst_WalletInstructionError_Timeout,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_WalletInstructionError_IncorrectPin {
        attempts_left_in_round: u8,
        is_final_round: bool,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_WalletInstructionError_Timeout {
        timeout_millis: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_wallet_instruction_result {
        tag: i32,
        kind: WalletInstructionResultKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union WalletInstructionResultKind {
        InstructionError: wire_cst_WalletInstructionResult_InstructionError,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_WalletInstructionResult_InstructionError {
        error: *mut wire_cst_wallet_instruction_error,
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;
