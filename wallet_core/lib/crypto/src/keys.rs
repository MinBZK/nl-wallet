use std::error::Error;

use aes_gcm::Aes256Gcm;
use aes_gcm::Key;
use aes_gcm::KeySizeUser;
use aes_gcm::Nonce;
use aes_gcm::aead::Aead;
use derive_more::AsRef;
use derive_more::From;
use derive_more::Into;
use p256::ecdsa::Signature;
use p256::ecdsa::VerifyingKey;
use serde::Deserialize;
use serde::Serialize;
use serde::de;

use crate::utils;

#[trait_variant::make(EcdsaKeySend: Send)]
pub trait EcdsaKey {
    type Error: Error + Send + Sync + 'static;

    async fn verifying_key(&self) -> Result<VerifyingKey, Self::Error>;

    /// Attempt to sign the given message, returning a digital signature on
    /// success, or an error if something went wrong.
    ///
    /// The main intended use case for signing errors is when communicating
    /// with external signers, e.g. cloud KMS, HSMs, or other hardware tokens.
    async fn try_sign(&self, msg: &[u8]) -> Result<Signature, Self::Error>;
}

/// Contract for ECDSA private keys which are short-lived and deterministically derived from a PIN.
pub trait EphemeralEcdsaKey: EcdsaKey {}

/// Contract for ECDSA private keys that are stored in some form of secure hardware from which they cannot be extracted,
/// e.g., a HSM, Android's TEE/StrongBox, or Apple's SE.
pub trait SecureEcdsaKey: EcdsaKey {}

// The `SigningKey` is an `EcdsaKey` but not a `SecureEcdsaKey` (except in mock/tests).
impl EcdsaKeySend for p256::ecdsa::SigningKey {
    type Error = p256::ecdsa::Error;

    async fn verifying_key(&self) -> Result<VerifyingKey, Self::Error> {
        Ok(*self.verifying_key())
    }

    async fn try_sign(&self, msg: &[u8]) -> Result<Signature, Self::Error> {
        p256::ecdsa::signature::Signer::try_sign(self, msg)
    }
}

#[trait_variant::make(Send)]
pub trait EncryptionKey {
    type Error: Error + Send + Sync + 'static;

    async fn encrypt(&self, msg: &[u8]) -> Result<Vec<u8>, Self::Error>;
    async fn decrypt(&self, msg: &[u8]) -> Result<Vec<u8>, Self::Error>;
}

/// Contract for encryption keys suitable for use in the wallet, e.g. for securely storing the database key.
/// Should be sufficiently secured e.g. through Android's TEE/StrongBox or Apple's SE.
pub trait SecureEncryptionKey: EncryptionKey {}

// `Aes256Gcm` is an `EncryptionKey` but not a `SecureEncryptionKey` (except in mock/tests).
impl EncryptionKey for Aes256Gcm {
    type Error = aes_gcm::Error;

    async fn encrypt(&self, msg: &[u8]) -> Result<Vec<u8>, Self::Error> {
        // Generate a random nonce
        let nonce_bytes = utils::random_bytes(12);
        let nonce = Nonce::from_slice(&nonce_bytes); // 96-bits; unique per message

        // Encrypt the provided message
        let encrypted_msg = <Aes256Gcm as Aead>::encrypt(self, nonce, msg)?;

        // concatenate nonce with encrypted payload
        let result = nonce_bytes.into_iter().chain(encrypted_msg).collect();

        Ok(result)
    }

    async fn decrypt(&self, msg: &[u8]) -> Result<Vec<u8>, Self::Error> {
        // Re-create the nonce from the first 12 bytes
        let nonce = Nonce::from_slice(&msg[..12]);

        // Decrypt the provided message with the retrieved nonce
        <Aes256Gcm as Aead>::decrypt(self, nonce, &msg[12..])
    }
}

/// This trait is included with keys that are uniquely identified by a string.
pub trait WithIdentifier {
    fn identifier(&self) -> &str;
}

pub trait WithVerifyingKey {
    type Error: Error + Send + Sync + 'static;

    async fn verifying_key(&self) -> Result<VerifyingKey, Self::Error>;
}

impl<T: EcdsaKey> WithVerifyingKey for T {
    type Error = T::Error;

    async fn verifying_key(&self) -> Result<VerifyingKey, Self::Error> {
        self.verifying_key().await
    }
}

/// Contract for ECDSA private keys suitable for credentials.
/// Should be sufficiently secured e.g. through a HSM, or Android's TEE/StrongBox or Apple's SE.
pub trait CredentialEcdsaKey: WithVerifyingKey + WithIdentifier {
    // from WithIdentifier: identifier()
    // from WithVerifyingKey: verifying_key()
}

/// A newtype around `Vec<u8>` that represent an assertion generated by Apple AppAttest.
/// It is to be treated as opaque bytes until received by the server.
#[derive(Debug, Clone, From, Into, AsRef, Serialize, Deserialize)]
#[as_ref(forward)]
pub struct AppleAssertion(Vec<u8>);

/// Represents a symmetric encryption key.
///
/// The `SymmetricKey` struct is used to encapsulate the raw bytes of a symmetric key,
/// which can be used in cryptographic operations such as encryption and decryption.
/// It can be deserialized from a hex-encoded string, e.g. `"01020304"`.
///
/// # Attributes
/// - `bytes` (`Vec<u8>`): A vector of bytes representing the symmetric key.
///
/// # Example
/// ```rust
/// use crypto::SymmetricKey;
///
/// let key_bytes = vec![0x01, 0x02, 0x03, 0x04];
/// let symmetric_key: SymmetricKey = key_bytes.into();
/// ```
#[derive(Clone, From, Into, AsRef)]
pub struct SymmetricKey {
    bytes: Vec<u8>,
}

impl SymmetricKey {
    pub fn key<B>(&self) -> &Key<B>
    where
        B: KeySizeUser,
    {
        Key::<B>::from_slice(self.bytes.as_slice())
    }
}

impl<'de> Deserialize<'de> for SymmetricKey {
    fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        String::deserialize(deserializer)
            .map(hex::decode)?
            .map(Into::into)
            .map_err(de::Error::custom)
    }
}

#[cfg(any(test, feature = "mock_secure_keys"))]
mod mock_secure_keys {
    use aes_gcm::Aes256Gcm;
    use p256::ecdsa::SigningKey;

    use super::EphemeralEcdsaKey;
    use super::SecureEcdsaKey;
    use super::SecureEncryptionKey;

    impl EphemeralEcdsaKey for SigningKey {}
    impl SecureEcdsaKey for SigningKey {}

    impl SecureEncryptionKey for Aes256Gcm {}
}
