use std::sync::Arc;

use axum::Router;
use axum::extract::State;
use axum::http::StatusCode;
use axum::response::Json;
use axum::routing::get;
use axum::routing::post;
use futures::TryFutureExt;
use futures::try_join;
use serde::Serialize;
use serde::de::DeserializeOwned;
use serde_with::base64::Base64;
use serde_with::serde_as;
use tower_http::trace::TraceLayer;
use tracing::info;
use tracing::warn;

use crypto::keys::EcdsaKey;
use crypto::p256_der::DerVerifyingKey;
use wallet_account::messages::instructions::ChangePinCommit;
use wallet_account::messages::instructions::ChangePinRollback;
use wallet_account::messages::instructions::ChangePinStart;
use wallet_account::messages::instructions::CheckPin;
use wallet_account::messages::instructions::Instruction;
use wallet_account::messages::instructions::InstructionAndResult;
use wallet_account::messages::instructions::InstructionChallengeRequest;
use wallet_account::messages::instructions::InstructionResultMessage;
use wallet_account::messages::instructions::PerformIssuance;
use wallet_account::messages::instructions::PerformIssuanceWithWua;
use wallet_account::messages::instructions::Sign;
use wallet_account::messages::registration::Certificate;
use wallet_account::messages::registration::Challenge;
use wallet_account::messages::registration::Registration;
use wallet_account::messages::registration::WalletCertificate;
use wallet_account::signed::ChallengeResponse;
use wallet_provider_service::account_server::GoogleCrlProvider;
use wallet_provider_service::account_server::IntegrityTokenDecoder;
use wallet_provider_service::instructions::HandleInstruction;
use wallet_provider_service::instructions::ValidateInstruction;
use wallet_provider_service::wte_issuer::WteIssuer;

use crate::errors::WalletProviderError;
use crate::router_state::RouterState;

/// All handlers should return this result. The [`WalletProviderError`] wraps
/// a [`StatusCode`] and JSON body, all top-level errors should be convertible
/// to this type.
///
/// For any errors there are generated by `axum` before we get to the handlers
/// this custom error will not be used however. In this case `axum` will return
/// the appropriate HTTP response codes within the 4xx range and the body will
/// contain a plain text string instead. Since this amounts to programmer error
/// and this is not a public API, having error responses in that do not contain
/// the custom JSON body in those cases is acceptable. The client should still
/// be able to handle these errors appropriately.
type Result<T> = std::result::Result<T, WalletProviderError>;

pub fn router<GRC, PIC>(router_state: RouterState<GRC, PIC>) -> Router
where
    GRC: GoogleCrlProvider + Send + Sync + 'static,
    PIC: IntegrityTokenDecoder + Send + Sync + 'static,
{
    let state = Arc::new(router_state);

    Router::new()
        .merge(health_router())
        .nest(
            "/api/v1",
            Router::new()
                .route("/enroll", post(enroll))
                .route("/createwallet", post(create_wallet))
                .route("/instructions/challenge", post(instruction_challenge))
                .route(
                    &format!("/instructions/{}", ChangePinStart::NAME),
                    post(change_pin_start),
                )
                .route(
                    &format!("/instructions/{}", ChangePinRollback::NAME),
                    post(change_pin_rollback),
                )
                .route(
                    &format!("/instructions/{}", ChangePinCommit::NAME),
                    post(handle_instruction::<ChangePinCommit, _, _, _>),
                )
                .route(
                    &format!("/instructions/{}", CheckPin::NAME),
                    post(handle_instruction::<CheckPin, _, _, _>),
                )
                .route(
                    &format!("/instructions/{}", Sign::NAME),
                    post(handle_instruction::<Sign, _, _, _>),
                )
                .route(
                    &format!("/instructions/{}", PerformIssuance::NAME),
                    post(handle_instruction::<PerformIssuance, _, _, _>),
                )
                .route(
                    &format!("/instructions/{}", PerformIssuanceWithWua::NAME),
                    post(handle_instruction::<PerformIssuanceWithWua, _, _, _>),
                )
                .layer(TraceLayer::new_for_http())
                .with_state(Arc::clone(&state)),
        )
        .nest(
            "/config",
            Router::new()
                .route("/public-keys", get(public_keys))
                .layer(TraceLayer::new_for_http())
                .with_state(Arc::clone(&state)),
        )
}

fn health_router() -> Router {
    Router::new().route("/health", get(|| async {}))
}

async fn enroll<GRC, PIC>(State(state): State<Arc<RouterState<GRC, PIC>>>) -> Result<(StatusCode, Json<Challenge>)> {
    info!("Received enroll request, creating registration challenge");

    let challenge = state
        .account_server
        .registration_challenge(&state.certificate_signing_key)
        .await
        .inspect_err(|error| warn!("generating wallet registration challenge failed: {}", error))?;

    let body = Challenge { challenge };

    info!("Replying with registration challenge");

    Ok((StatusCode::OK, body.into()))
}

async fn create_wallet<GRC, PIC>(
    State(state): State<Arc<RouterState<GRC, PIC>>>,
    Json(payload): Json<ChallengeResponse<Registration>>,
) -> Result<(StatusCode, Json<Certificate>)>
where
    GRC: GoogleCrlProvider,
    PIC: IntegrityTokenDecoder,
{
    info!("Received create wallet request, registering with account server");

    let cert = state
        .account_server
        .register(&state.certificate_signing_key, payload, &state.user_state)
        .await
        .inspect_err(|error| warn!("wallet registration failed: {}", error))?;

    let body = Certificate { certificate: cert };

    info!("Replying with the created wallet certificate");

    Ok((StatusCode::CREATED, body.into()))
}

async fn instruction_challenge<GRC, PIC>(
    State(state): State<Arc<RouterState<GRC, PIC>>>,
    Json(payload): Json<InstructionChallengeRequest>,
) -> Result<(StatusCode, Json<Challenge>)> {
    info!("Received challenge request, creating challenge");

    let challenge = state
        .account_server
        .instruction_challenge(payload, state.as_ref(), &state.user_state)
        .await
        .inspect_err(|error| warn!("generating instruction challenge failed: {}", error))?;

    let body = Challenge { challenge };

    info!("Replying with the created challenge");

    Ok((StatusCode::OK, body.into()))
}

async fn handle_instruction<I, R, GRC, PIC>(
    State(state): State<Arc<RouterState<GRC, PIC>>>,
    Json(payload): Json<Instruction<I>>,
) -> Result<(StatusCode, Json<InstructionResultMessage<R>>)>
where
    I: InstructionAndResult<Result = R> + HandleInstruction<Result = R> + ValidateInstruction,
    R: Serialize + DeserializeOwned,
{
    info!("received {} instruction", I::NAME);
    let body = state
        .handle_instruction(payload)
        .await
        .inspect_err(|error| warn!("handling {} instruction failed: {}", I::NAME, error))?;

    Ok((StatusCode::OK, body.into()))
}

async fn change_pin_start<GRC, PIC>(
    State(state): State<Arc<RouterState<GRC, PIC>>>,
    Json(payload): Json<Instruction<ChangePinStart>>,
) -> Result<(StatusCode, Json<InstructionResultMessage<WalletCertificate>>)> {
    info!("Received change pin start request, handling the ChangePinStart instruction");

    let result = state
        .account_server
        .handle_change_pin_start_instruction(
            payload,
            (&state.instruction_result_signing_key, &state.certificate_signing_key),
            state.as_ref(),
            &state.pin_policy,
            &state.user_state,
        )
        .await
        .inspect_err(|error| warn!("handling ChangePinStart instruction failed: {}", error))?;

    let body = InstructionResultMessage { result };

    Ok((StatusCode::OK, body.into()))
}

async fn change_pin_rollback<GRC, PIC>(
    State(state): State<Arc<RouterState<GRC, PIC>>>,
    Json(payload): Json<Instruction<ChangePinRollback>>,
) -> Result<(StatusCode, Json<InstructionResultMessage<()>>)> {
    info!("Received change pin rollback request, handling the ChangePinRollback instruction");

    let result = state
        .account_server
        .handle_change_pin_rollback_instruction(
            payload,
            &state.instruction_result_signing_key,
            state.as_ref(),
            &state.pin_policy,
            &state.user_state,
        )
        .await
        .inspect_err(|error| warn!("handling ChangePinRollback instruction failed: {}", error))?;

    let body = InstructionResultMessage { result };

    info!("Replying with the instruction result");

    Ok((StatusCode::OK, body.into()))
}

#[serde_as]
#[derive(Serialize)]
struct PublicKeys {
    #[serde_as(as = "Base64")]
    certificate_public_key: DerVerifyingKey,
    #[serde_as(as = "Base64")]
    instruction_result_public_key: DerVerifyingKey,
    #[serde_as(as = "Base64")]
    wte_signing_key: DerVerifyingKey,
}

async fn public_keys<GRC, PIC>(
    State(state): State<Arc<RouterState<GRC, PIC>>>,
) -> Result<(StatusCode, Json<PublicKeys>)> {
    let (certificate_public_key, instruction_result_public_key, wte_signing_key) = try_join!(
        state
            .certificate_signing_key
            .verifying_key()
            .map_err(WalletProviderError::Hsm),
        state
            .instruction_result_signing_key
            .verifying_key()
            .map_err(WalletProviderError::Hsm),
        state
            .user_state
            .wte_issuer
            .public_key()
            .map_err(WalletProviderError::Wte)
    )
    .inspect_err(|error| warn!("getting wallet provider public keys failed: {}", error))?;

    let body = PublicKeys {
        certificate_public_key: certificate_public_key.into(),
        instruction_result_public_key: instruction_result_public_key.into(),
        wte_signing_key: wte_signing_key.into(),
    };

    Ok((StatusCode::OK, body.into()))
}
